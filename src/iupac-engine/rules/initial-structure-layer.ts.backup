import type { IUPACRule } from '../types';
import { BLUE_BOOK_RULES } from '../types';
import type { ImmutableNamingContext } from '../immutable-context';
import { ExecutionPhase } from '../immutable-context';
import { P2_PARENT_HYDRIDE_RULES } from './bluebook/P-2/parent-hydride-rules';
import { P3_SUBSTITUENT_RULES } from './bluebook/P-3/substituent-rules';
import { RING_NUMBERING_RULE } from './numbering-layer';
import { findRings, analyzeRings } from 'src/utils/ring-analysis';
import type { Molecule, Chain, BondType } from 'types';
import { BondType as BondTypeEnum } from 'types';
import { getChainFunctionalGroupPriority } from '../naming/iupac-chains';

/**
 * Initial Structure Analysis Rule
 *
 * Seed candidateChains (and minimal substituent info) using the
 * iupac chain utilities so that parent-selection rules have
 * reasonable starting candidates. This avoids putting analysis
 * logic directly into the mutable context implementation.
 */
export const INITIAL_STRUCTURE_ANALYSIS_RULE: IUPACRule = {
  id: 'init-structure-analysis',
  name: 'Initial Structure Analysis',
  description: 'Seed candidate chains using iupac chain utilities',
  blueBookReference: BLUE_BOOK_RULES.P44_3_1,
  priority: 2000,
  conditions: (context: ImmutableNamingContext) => {
    const chains = context.getState().candidateChains;
    if (process.env.VERBOSE) {
      console.log(`[INITIAL_STRUCTURE_ANALYSIS_RULE] condition check: chains=${chains?.length || 0}`);
    }
    // Run when no candidate chains are present
    return !chains || chains.length === 0;
  },
  action: (context: ImmutableNamingContext) => {
    const molecule = context.getState().molecule;
    try {
      // First, detect rings if not already present
      let ringSystems: any[] = [];
      if (molecule && Array.isArray(molecule.rings) && molecule.rings.length > 0) {
        // Use parser-provided rings
        for (const ringIdxs of molecule.rings) {
          const atoms = ringIdxs.map((i: number) => molecule.atoms[i]).filter(Boolean);
          if (atoms.length < 3) continue;
          const bonds = molecule.bonds.filter((b: any) => ringIdxs.includes(b.atom1) && ringIdxs.includes(b.atom2));
          ringSystems.push({ atoms, bonds, rings: [ringIdxs], size: atoms.length });
        }
      } else {
        // Detect rings using ring analysis utilities
        const ringInfo = analyzeRings(molecule as any);
        if (ringInfo.rings.length > 0) {
          for (const ring of ringInfo.rings) {
            const atoms = ring.map((idx: number) => molecule.atoms[idx]).filter(Boolean);
            const bonds = molecule.bonds.filter((b: any) =>
              ring.includes(b.atom1) && ring.includes(b.atom2)
            );
            ringSystems.push({ atoms, bonds, rings: [ring], size: atoms.length });
          }
        }
      }

      if (ringSystems.length > 0) {
        // Update state with candidateRings so ring-analysis rules run
        let ctxWithRings = context.withStateUpdate(
          (state: any) => ({ ...state, candidateRings: ringSystems }),
          'init-structure-analysis',
          'Initial Structure Analysis',
          BLUE_BOOK_RULES.P44_3_1,
          ExecutionPhase.PARENT_STRUCTURE,
          `Detected ${ringSystems.length} ring system(s)`
        );
        // eslint-disable-next-line no-param-reassign
        // @ts-ignore - reassign local context for further actions
        context = ctxWithRings as unknown as ImmutableNamingContext;
      }

       // Local require to avoid circular imports
       // eslint-disable-next-line @typescript-eslint/no-var-requires
       const { findMainChain, findSubstituents } = require('../naming/iupac-chains');
       const mainChain = findMainChain(molecule as any);
       console.log(`[initial-structure-layer] findMainChain returned: ${mainChain?.join(',') || 'empty'}`);
       if (!mainChain || mainChain.length === 0) return context;

      const candidates: any[] = [];
      // Use only the main chain (already optimally oriented by findMainChain)
      const main = mainChain;
      if (main.length >= 2) {
        const atoms = main.map((idx: number) => molecule.atoms[idx]).filter(Boolean);
        const bonds: any[] = [];
        const multipleBonds: any[] = [];

        for (let i = 0; i < main.length - 1; i++) {
          const a = main[i]!;
          const b = main[i + 1]!;
          const bond = molecule.bonds.find((bb: any) => (bb.atom1 === a && bb.atom2 === b) || (bb.atom1 === b && bb.atom2 === a));
          if (bond) {
            bonds.push(bond);
            if (bond.type !== 'single') {
              multipleBonds.push({ atoms: [molecule.atoms[a], molecule.atoms[b]], bond, type: bond.type === 'double' ? 'double' : 'triple', locant: i + 1 });
            }
          }
        }

        const subsRaw = findSubstituents(molecule as any, main as number[]);
        const substituents = subsRaw.map((s: any) => ({ atoms: [], bonds: [], type: s.name, locant: parseInt(s.position, 10), isPrincipal: false }));

        console.log(`Candidate chain: ${main.join(',')}, length: ${atoms.length}`);
        candidates.push({ atoms, bonds, length: atoms.length, multipleBonds, substituents, locants: Array.from({ length: atoms.length }, (_, i) => i + 1) });
      }

      return context.withUpdatedCandidates(
        candidates,
        'init-structure-analysis',
        'Initial Structure Analysis',
        BLUE_BOOK_RULES.P44_3_1,
        ExecutionPhase.PARENT_STRUCTURE,
        'Seeded candidate chains from iupac chain utilities'
      );
    } catch (err) {
      // If utilities unavailable, do nothing and let later rules/fallbacks run
      return context;
    }
  }
};

/**
 * Export all initial structure layer rules
 */
export const INITIAL_STRUCTURE_LAYER_RULES: IUPACRule[] = [
  // P-2 rules run first to select simple parent hydrides
  ...P2_PARENT_HYDRIDE_RULES,
  // Ring numbering must run before P-3 substituent detection
  RING_NUMBERING_RULE,
  // P-3 rules run after parent selection to detect substituents
  ...P3_SUBSTITUENT_RULES,
  // P-44.1.1 runs before P-44.4 to select chains with functional groups
  P44_1_1_PRINCIPAL_CHARACTERISTIC_GROUPS_RULE,
  // Initial structure analysis seeds candidates
  INITIAL_STRUCTURE_ANALYSIS_RULE,
  // P-44.4 selects ring vs chain when no functional groups
  P44_4_RING_CHAIN_SELECTION_RULE
];

    const heteroatoms = molecule.atoms.filter(atom =>
      HETEROATOM_HYDRIDES.includes(atom.symbol)
    );

    // If exactly one heteroatom with correct valence exists, P-2.1 should handle it
    if (heteroatoms.length === 1) {
      const heteroatom = heteroatoms[0]!;
      const implicitHydrogens = heteroatom.hydrogens || 0;
      const heteroatomIndex = molecule.atoms.indexOf(heteroatom);
      const bondOrders = molecule.bonds
        .filter(bond => bond.atom1 === heteroatomIndex || bond.atom2 === heteroatomIndex)
        .reduce((sum, bond) => {
          const order = bond.type === 'single' ? 1 : bond.type === 'double' ? 2 : bond.type === 'triple' ? 3 : 1;
          return sum + order;
        }, 0);
      const totalValence = bondOrders + implicitHydrogens;
      const expectedValence = EXPECTED_VALENCE[heteroatom.symbol];

      if (totalValence === expectedValence) {
        // Heteroatom parent is present - let P-2.1 handle it
        if (process.env.VERBOSE) console.log('P-44.4: deferring to P-2.1 heteroatom parent');
        return false;
      }
    }

    return true;
  },
  action: (context: ImmutableNamingContext) => {
    const candidateRings = context.getState().candidateRings;
    const candidateChains = context.getState().candidateChains;

    if (!candidateRings || !candidateChains) {
      return context;
    }

    // According to P-44.4, ring systems generally take precedence over chains
    const ring = candidateRings[0];
    if (!ring) {
      return context;
    }
    const size = ring.size || (ring.atoms ? ring.atoms.length : 0);
    const type = ring.type || (ring.atoms && ring.atoms.some((a: any) => a.aromatic) ? 'aromatic' : 'aliphatic');
    let name = '';
    if (type === 'aromatic') {
      const aromaticNames: { [key: number]: string } = { 6: 'benzene', 5: 'cyclopentadiene', 7: 'cycloheptatriene' };
      name = aromaticNames[size] || `aromatic-${size}-membered`;
    } else {
      const ringNames: { [key: number]: string } = { 3: 'cyclopropane', 4: 'cyclobutane', 5: 'cyclopentane', 6: 'cyclohexane', 7: 'cycloheptane', 8: 'cyclooctane' };
      name = ringNames[size] || `cyclo${size}ane`;
    }
    const locants = ring.atoms ? ring.atoms.map((_: any, idx: number) => idx + 1) : [];

    const parentStructure = {
      type: 'ring' as const,
      ring,
      name,
      locants
    };

    return context.withParentStructure(
      parentStructure,
      'P-44.4',
      'Ring vs Chain Selection',
      'P-44.4',
      ExecutionPhase.PARENT_STRUCTURE,
      'Selected ring system as parent structure over chain'
    );
  }
};

/**
 * Rule: P-44.1.1 - Maximum Number of Principal Characteristic Groups
 * 
 * According to IUPAC Blue Book P-44.1.1, the parent structure should contain
 * the maximum number of principal characteristic groups (suffixes like -COOH, -one, etc.).
 * 
 * This rule compares chains with rings and selects chains that have principal functional
 * groups over rings (which typically have zero such groups).
 */
export const P44_1_1_PRINCIPAL_CHARACTERISTIC_GROUPS_RULE: IUPACRule = {
  id: 'P-44.1.1',
  name: 'Maximum Number of Principal Characteristic Groups',
  description: 'Select parent with maximum number of principal characteristic groups',
  blueBookReference: BLUE_BOOK_RULES.P44_1,
  priority: 65, // Higher than P-44.4 (60) but lower than P-2.1 (150)
  conditions: (context: ImmutableNamingContext) => {
    const state = context.getState();
    // Skip if parent structure already selected
    if (state.parentStructure) {
      if (process.env.VERBOSE) console.log('[P-44.1.1] Skipping - parent already selected');
      return false;
    }
    // Only apply if we have both chains and rings to compare
    const chains = state.candidateChains as Chain[];
    const rings = state.candidateRings;
    const shouldApply = chains.length > 0 && rings && rings.length > 0;
    if (process.env.VERBOSE) {
      console.log(`[P-44.1.1] Conditions check: chains=${chains.length}, rings=${rings?.length || 0}, shouldApply=${shouldApply}`);
    }
    return shouldApply;
  },
  action: (context: ImmutableNamingContext) => {
    const state = context.getState();
    const chains = state.candidateChains as Chain[];
    const molecule = state.molecule as Molecule;
    
    if (process.env.VERBOSE) {
      console.log('[P-44.1.1] Action executing...');
      console.log(`[P-44.1.1] chains.length=${chains?.length}, molecule=${!!molecule}`);
    }
    
    if (!chains || chains.length === 0 || !molecule) return context;
    
    // Count functional groups that can be expressed as suffixes on each chain
    // Priority >= 4 means ketone/aldehyde or higher (carboxylic acid = 6, amide = 5, etc.)
    const chainFGCounts = chains.map(chain => {
      // Get priority from utility function (may use different logic)
      const atomIndices = chain.atoms.map(atom => {
        const idx = molecule.atoms.findIndex(a => a === atom);
        return idx;
      });
      const priority = getChainFunctionalGroupPriority(atomIndices, molecule);
      
      // Count atoms in the chain that have principal functional groups
      let fgCount = 0;
      for (const atom of chain.atoms) {
        if (!atom || atom.symbol !== 'C') continue;
        
        // Find this atom's index in the molecule
        const atomIdx = molecule.atoms.findIndex(a => a === atom);
        if (atomIdx === -1) continue;
        
        // Check for C=O (ketone/aldehyde)
        let hasDoubleO = false;
        for (const bond of molecule.bonds) {
          if (bond.atom1 !== atomIdx && bond.atom2 !== atomIdx) continue;
          const neighIdx = bond.atom1 === atomIdx ? bond.atom2 : bond.atom1;
          const neigh = molecule.atoms[neighIdx];
          // Check for double bond to oxygen
          if (neigh?.symbol === 'O' && bond.type === BondTypeEnum.DOUBLE) {
            hasDoubleO = true;
            break;
          }
        }
        if (hasDoubleO) fgCount++;
      }
      
      if (process.env.VERBOSE) {
        console.log(`[P-44.1.1] Chain with ${chain.atoms.length} atoms: priority=${priority}, fgCount=${fgCount}`);
      }
      
      return { chain, priority, fgCount };
    });
    
    // Find maximum functional group count
    const maxFGCount = Math.max(...chainFGCounts.map(c => c.fgCount));
    
    if (process.env.VERBOSE) {
      console.log(`[P-44.1.1] maxFGCount=${maxFGCount}`);
      console.log(`[P-44.1.1] candidateRings.length=${state.candidateRings?.length || 0}`);
    }
    
    // Rings typically have 0 principal characteristic groups (benzene doesn't have -C=O groups)
    // If any chain has principal functional groups (ketones, aldehydes, etc.), prefer it
    if (maxFGCount > 0) {
      const functionalChains = chainFGCounts
        .filter(c => c.fgCount === maxFGCount)
        .map(c => c.chain);
      
      if (process.env.VERBOSE) {
        console.log(`[P-44.1.1] Selecting ${functionalChains.length} chains with ${maxFGCount} functional groups, clearing rings`);
      }
      
      return context.withUpdatedCandidates(
        functionalChains,
        'P-44.1.1',
        'Maximum Number of Principal Characteristic Groups',
        BLUE_BOOK_RULES.P44_1,
        ExecutionPhase.PARENT_STRUCTURE,
        `Selected chains with ${maxFGCount} principal characteristic groups, ignoring rings`
      ).withStateUpdate(
        (state) => ({
          ...state,
          candidateRings: [], // Clear rings since functional chain takes precedence
          p44_1_1_applied: true
        }),
        'P-44.1.1',
        'Maximum Number of Principal Characteristic Groups',
        BLUE_BOOK_RULES.P44_1,
        ExecutionPhase.PARENT_STRUCTURE,
        'Cleared candidate rings in favor of chains with principal characteristic groups'
      );
    }
    
    // If no chains have principal functional groups, let normal rules proceed
    // (rings may win via P-44.4)
    if (process.env.VERBOSE) {
      console.log('[P-44.1.1] No functional groups found, letting other rules proceed');
    }
    return context;
  }
};

/**
 * Rule: P-44.4 - Ring vs Chain Selection
 *
 * Determine whether to use ring system or chain as parent structure.
 * Ring systems generally have seniority over chains, UNLESS there's a
 * heteroatom parent candidate (P-2.1 takes priority).
 */
export const P44_4_RING_CHAIN_SELECTION_RULE: IUPACRule = {
  // P-2 rules run first to select simple parent hydrides
  ...P2_PARENT_HYDRIDE_RULES,
  // Ring numbering must run before P-3 substituent detection
  RING_NUMBERING_RULE,
  // P-3 rules run after parent selection to detect substituents
  ...P3_SUBSTITUENT_RULES,
  INITIAL_STRUCTURE_ANALYSIS_RULE,
  P44_4_RING_CHAIN_SELECTION_RULE
];
