import type { Molecule } from 'types';
import { BondType } from 'types';
import { getChainFunctionalGroupPriority } from './functional-group-detector';
import { analyzeRings } from '../ring-analysis';
import { createDefaultChainSelector } from './chain-selector';
import type { Chain } from './iupac-types';

/**
 * Chain selection logic for IUPAC naming.
 *
 * Selection rules (in order of precedence):
 * 1. Chain containing the principal functional group (highest priority)
 * 2. Longest chain by carbon count
 * 3. Longest chain by total atom count
 * 4. Best numbering by locant positions
 * 5. First found (arbitrary)
 */

export interface ChainSelectionResult {
   chain: number[];
   reason: string;
 }
 
/**
 * Find chains starting from functional group carbons.
 * For molecules with carboxylic acids, aldehydes, etc., build chains starting from the functional group.
 * These chains can pass through aromatic rings.
 */
function findChainsFromFunctionalGroups(molecule: Molecule): number[][] {
   const chains: number[][] = [];
   
   // Analyze ring membership ONCE outside the DFS to avoid repeated computation
   const ringInfo = analyzeRings(molecule);
   const isRingAtom = (atomIdx: number): boolean => {
     return ringInfo.getRingsContainingAtom(atomIdx).length > 0;
   };
   
   // Find carbons with functional groups
    for (let i = 0; i < molecule.atoms.length; i++) {
      const atom = molecule.atoms[i];
      if (!atom || atom.symbol !== 'C') continue;
      
      const bonds = molecule.bonds.filter(b => b.atom1 === i || b.atom2 === i);
      
      // Check for carboxylic acid (C=O bond to oxygen)
      const hasCarboxyl = bonds.some(b => {
        const neighbor = molecule.atoms[b.atom1 === i ? b.atom2 : b.atom1];
        return neighbor?.symbol === 'O' && b.type === BondType.DOUBLE;
      });
      
       // Exclude carboxyl carbons from being part of the main chain except as terminals
       if (hasCarboxyl) {
         // For dicarboxylic acids, exclude carboxyl carbons from chain except as terminal atoms
         // Only include as chain start if it is a terminal carboxyl carbon (i.e., only one neighbor is carbon)
         const carboxylNeighbors = bonds.filter(b => {
           const neighbor = molecule.atoms[b.atom1 === i ? b.atom2 : b.atom1];
           return neighbor?.symbol === 'C';
         });
         // Allow carboxyl carbons that have at least one carbon neighbor to be chain starts.
         // Previously we required exactly one carbon neighbor (terminal only), but that
         // excluded valid parent chains in some cases (dicarboxyl/ester arrangements).
         if (carboxylNeighbors.length === 0) continue; // need at least one carbon neighbor
         // Found terminal carboxylic acid carbon, build chain from it
         const visited = new Set<number>();
         const chain: number[] = [];
         dfsChainFromFunctionalGroup(i, molecule, visited, chain, chains, isRingAtom);
       }
    }
   
   // Log all chains generated by DFS for debugging
   if (process.env.VERBOSE) {
     console.debug('[findChainsFromFunctionalGroups] All chains generated by DFS:', chains.map(c => ({ chain: c, length: c.length })));
   }
   
   // Remove duplicates and sub-chains
   const uniqueChains = new Map<string, number[]>();
   for (const chain of chains) {
    const canonical = canonicalizeAcyclicChainOrder(chain, molecule);
    const key = [...canonical].sort((a, b) => a - b).join(',');
    const existing = uniqueChains.get(key);
    if (!existing || canonical.length > existing.length) {
      uniqueChains.set(key, canonical);
    }
   }
   
   if (process.env.VERBOSE) {
     console.debug('[findChainsFromFunctionalGroups] After deduplication:', Array.from(uniqueChains.values()).map(c => ({ chain: c, length: c.length })));
   }
   
   return Array.from(uniqueChains.values()).sort((a, b) => b.length - a.length);
 }
 
/**
 * DFS to find longest chain from a functional group carbon.
 * Only extends through saturated (non-aromatic) carbons.
 */
function dfsChainFromFunctionalGroup(
    atom: number,
    molecule: Molecule,
    visited: Set<number>,
    currentChain: number[],
    allChains: number[][],
    isRingAtom: (atomIdx: number) => boolean
  ): void {
    visited.add(atom);
    currentChain.push(atom);
    
    // Record this chain
    if (currentChain.length >= 2) {
      allChains.push([...currentChain]);
    }
    
    // Try extending through saturated carbon neighbors only
    const neighbors = getNeighbors(atom, molecule);
    let extended = false;
    
    for (const neighbor of neighbors) {
      const neighborAtom = molecule.atoms[neighbor];
      // Don't extend into ring atoms - rings should be treated as substituents
      if (isRingAtom(neighbor)) {
        continue;
      }
      // Extend only if it's a non-aromatic carbon and not yet visited
      if (!visited.has(neighbor) && neighborAtom?.symbol === 'C' && !neighborAtom.aromatic) {
        extended = true;
        dfsChainFromFunctionalGroup(neighbor, molecule, visited, currentChain, allChains, isRingAtom);
      }
    }
    
    // If no extension possible, this is a terminal chain
    if (!extended && currentChain.length >= 1) {
      allChains.push([...currentChain]);
    }
    
    // Backtrack
    currentChain.pop();
    visited.delete(atom);
  }

/**
 * Select the principal (main) chain from a molecule.
 * Returns the longest chain that should be used as the parent in IUPAC naming.
 */
export function selectPrincipalChain(molecule: Molecule): ChainSelectionResult {
  // New policy (per request):
  // - Longest carbon chain that contains the principal group.
  // - If multiple, choose one with more substituents.
  // - If still tied, choose alphabetically smaller substituents.

  // Gather all candidate chains: include chains found from functional groups plus general acyclic chains
   const fgChains = findChainsFromFunctionalGroups(molecule);
   const acyclicChains = findAllAcyclicChains(molecule);
   const heteroChains = findHeteroatomChains(molecule);
   const ringChains = findRingBasedChains(molecule);
   const allCandidatesMap = new Map<string, number[]>();

   for (const c of fgChains) allCandidatesMap.set(c.join(','), c);
   for (const c of acyclicChains) allCandidatesMap.set(c.join(','), c);
   for (const c of heteroChains) allCandidatesMap.set(c.join(','), c);
   for (const c of ringChains) allCandidatesMap.set(c.join(','), c);

const allCandidates = Array.from(allCandidatesMap.values());
  
    if (process.env.VERBOSE) {
      console.debug('[chain-selection] All candidates:', allCandidates.map(c => ({ chain: c, length: c.length })));
    }
    
    if (allCandidates.length === 0) {
      return { chain: [], reason: 'No candidate chains found' };
    }
  
    // IUPAC Rule: When functional group is attached to a ring via acyclic carbons,
    // prefer the acyclic chain (treat ring as substituent) over longer chains that
    // traverse through the ring.
    // Example: C1CCC(C(C)C(=O)O)CC1 â†’ "2-cyclohexylpropanoic acid" (not "nonanoic acid")
    const ringInfo = analyzeRings(molecule);
    const isRingAtom = (atomIdx: number): boolean => {
      return ringInfo.getRingsContainingAtom(atomIdx).length > 0;
    };
    
    // Check if we have a functional group carbon attached to a ring
    const allCarboxylCarbons = getAllCarboxylCarbons(molecule);
    if (allCarboxylCarbons.length === 1) {
      const fgCarbon = allCarboxylCarbons[0]!;
      if (process.env.VERBOSE) {
        console.debug('[chain-selection] Checking ring attachment: fgCarbon=', fgCarbon, 'isRingAtom=', isRingAtom(fgCarbon));
      }
      
      // Check if there's a path from FG carbon to a ring through acyclic carbons
      // This handles cases like C1CCC(C(C)C(=O)O)CC1 where COOH is 2 carbons away from ring
      const hasRingConnection = allCandidates.some(chain => {
        const chainSet = new Set(chain);
        if (!chainSet.has(fgCarbon)) return false;
        // Check if this chain contains both FG carbon and ring atoms
        const ringAtomsInChain = chain.filter(idx => isRingAtom(idx));
        return ringAtomsInChain.length > 0;
      });
      
      if (process.env.VERBOSE) {
        console.debug('[chain-selection] hasRingConnection=', hasRingConnection);
      }
      
      if (hasRingConnection) {
        // Prefer acyclic chains (chains that don't traverse through ring atoms)
        const acyclicChains = allCandidates.filter(chain => {
          const chainSet = new Set(chain);
          if (!chainSet.has(fgCarbon)) return false; // must contain FG carbon
          // Count how many ring atoms are in this chain
          const ringAtomsInChain = chain.filter(idx => isRingAtom(idx));
          return ringAtomsInChain.length === 0; // prefer chains with no ring atoms
        });
        
        if (process.env.VERBOSE) {
          console.debug('[chain-selection] acyclicChains count=', acyclicChains.length, 'chains=', acyclicChains.map(c => c.join('-')));
        }
        
        if (acyclicChains.length > 0) {
          if (process.env.VERBOSE) {
            console.debug('[chain-selection] FG attached to ring via acyclic carbons, preferring acyclic chains');
          }
          const outcome = selectBestChain(acyclicChains, molecule, 'Preferred acyclic chain (ring as substituent)');
          return { chain: outcome.chain, reason: outcome.reason || 'Preferred acyclic chain (ring as substituent)' };
        }
      }
    }
  
    // Special handling for dicarboxylic acids - detect early and handle consistently
   if (process.env.VERBOSE) {
     console.debug('[chain-selection] All carboxyl carbons:', allCarboxylCarbons);
   }
   if (allCarboxylCarbons.length > 1) {
    // Detect simple malonic-acid-like pattern and prefer the minimal 3-atom backbone
    // when appropriate (OC(=O)CC(=O)O). The helper isSimpleMalonicAcid implements
    // the necessary structural checks.
    try {
      // Compute minimal distance between carboxyl carbons
      let minDist = Infinity;
      let minPath: number[] = [];
      for (let i = 0; i < allCarboxylCarbons.length; i++) {
        for (let j = i + 1; j < allCarboxylCarbons.length; j++) {
          const p = findShortestPath(allCarboxylCarbons[i]!, allCarboxylCarbons[j]!, molecule);
          if (p.length > 0 && p.length < minDist) {
            minDist = p.length;
            minPath = p;
          }
        }
      }
      if (minPath.length > 0 && isSimpleMalonicAcid(molecule, allCarboxylCarbons, minPath.length - 1)) {
        if (process.env.VERBOSE) console.debug('[chain-selection] Detected simple malonic acid, preferring minimal backbone:', minPath);
        const outcome = selectBestChain([minPath], molecule, 'Preferred simple malonic acid backbone');
        return { chain: outcome.chain, reason: outcome.reason || 'Preferred simple malonic acid backbone' };
      }
    } catch (e) {
      // ignore and continue with existing dicarboxylic logic
    }
     // For dicarboxylic acids, we want the longest chain that includes both carboxyl groups
     // Find candidate chains that contain both carboxyl carbons
     const carboxylChainCandidates = allCandidates.filter(chain => {
       const chainSet = new Set(chain);
       return allCarboxylCarbons.every(carb => chainSet.has(carb));
     });
     
     if (process.env.VERBOSE) {
       console.debug('[chain-selection] Carboxyl chain candidates:', carboxylChainCandidates.map(c => ({ chain: c, length: c.length })));
     }
     
     if (carboxylChainCandidates.length > 0) {
       // For dicarboxylic acids, prefer the longest chain that contains both carboxyl groups
       let best = carboxylChainCandidates[0]!;
       for (const c of carboxylChainCandidates) {
         if (c.length > best.length) best = c;
       }
       
       if (process.env.VERBOSE) {
         console.debug('[chain-selection] Selected dicarboxylic chain:', best, 'length:', best.length);
       }
       
       const outcome = selectBestChain([best], molecule, `Preferred dicarboxylic acid chain (length ${best.length})`);
       return { chain: outcome.chain, reason: outcome.reason || `Preferred dicarboxylic acid chain (length ${best.length})` };
     }
   }

   // Filter to only chains of maximum length (IUPAC: prefer most highly branched among longest chains)
   const maxLen = Math.max(...allCandidates.map(c => c.length));
   const maxLenCandidates = allCandidates.filter(c => c.length === maxLen);

  // Allow one-carbon-shorter chains (maxLen-1) to win when they are strictly
  // preferred by the IUPAC tie-break rules (more substituents), i.e., when the
  // carbon-count difference is exactly 1 and the shorter chain is unanimously
  // preferred over all max-length candidates. This implements the IUPAC rule
  // that a shorter but more substituted chain may outrank a longer chain when
  // the difference is only one carbon.
  const secondMaxLen = Math.max(...allCandidates.map(c => c.length).filter(l => l < maxLen), 0);
  let effectiveMaxLenCandidates = maxLenCandidates;
  if (secondMaxLen === maxLen - 1) {
    const secondCandidates = allCandidates.filter(c => c.length === secondMaxLen);
    // For each candidate in secondCandidates, check if it is preferred over
    // every maxLen candidate according to the principal-preference comparator.
    const preferredSeconds = secondCandidates.filter(sec => {
      for (const big of maxLenCandidates) {
        // compareChainsPreferPrincipal(sec, big) === 1 means sec is better than big
        if (compareChainsPreferPrincipal(sec, big, molecule) !== 1) return false;
      }
      return true;
    });
    if (preferredSeconds.length > 0) {
      if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: one-carbon-shorter chains preferred over longest by substituent rules:', preferredSeconds.map(c => c.join('-')));
      effectiveMaxLenCandidates = preferredSeconds;
    }
  }

  // Determine principal functional group atom indices (atoms with highest per-atom FG priority)
  const principalAtoms = getPrincipalFunctionalGroupAtoms(molecule);

    if (principalAtoms.length === 0) {
      // No principal functional group â€” fall back to existing selection pipeline
      const ringInfo = analyzeRings(molecule);
      
      // Diagnostic logging gated by VERBOSE
      if (process.env.VERBOSE) {
        try {
          const fg = findChainsFromFunctionalGroups(molecule);
          const ac = findAllAcyclicChains(molecule);
          const rc = findRingBasedChains(molecule);
          console.debug('[chain-selection] VERBOSE: no principal FG, candidates counts:', { fgCount: fg.length, acCount: ac.length, rcCount: rc.length, ringCount: ringInfo.rings.length });
          console.debug('[chain-selection] VERBOSE: sample candidates', { fgSample: fg.slice(0,3), acSample: ac.slice(0,3), rcSample: rc.slice(0,3) });
        } catch (e) {}
      }

       // If there are ring-based candidates (fused/spiro/biphenyl unions), prefer
       // them when they are nearly as long as the longest carbon path. This helps
       // select aromatic/polycyclic parents (anthracene, biphenyl, benzoic parents)
       // in structures with no principal FG. Keep the threshold conservative
       // (allow ring candidate if length >= maxLen - 1) to avoid regressing long
       // aliphatic chain selection.
       try {
         if (ringChains && ringChains.length > 0) {
          const bestRingLen = Math.max(...ringChains.map(c => c.length));

          // Compute longest acyclic carbon chain length (if any acyclic chains exist)
          const longestAcyclicLen = acyclicChains && acyclicChains.length > 0 ? Math.max(...acyclicChains.map(c => c.length)) : 0;

          // Compute unsaturation scores for acyclic and ring candidates.
          const longestAcyclicUnsat = acyclicChains && acyclicChains.length > 0 ? Math.max(...acyclicChains.map(c => computeUnsaturationScore(c, molecule))) : 0;
          const bestRingUnsat = ringChains && ringChains.length > 0 ? Math.max(...ringChains.map(c => computeUnsaturationScore(c, molecule))) : 0;

          // If there are fully-aromatic ring unions whose unsaturation score
          // is greater-or-equal to the best acyclic unsaturation, prefer those
          // ring-union candidates. This follows the spec guidance where
          // unsaturation (including aromaticity) is considered before raw
          // chain length.
          const fullyAromaticRingChains = ringChains.filter(c => c.length >= 3 && c.every(i => molecule.atoms[i]?.aromatic));
          if (fullyAromaticRingChains.length > 0) {
            const aromaticBestUnsat = Math.max(...fullyAromaticRingChains.map(c => computeUnsaturationScore(c, molecule)));
            const maxAromaticLen = Math.max(...fullyAromaticRingChains.map(c => c.length));
            // Prefer aromatic ring unions when their unsaturation score is
            // strictly greater than the best acyclic alternative. This allows
            // aromatic monocyclic parents (e.g., substituted benzene) to be
            // selected over longer acyclic paths that cut through the ring.
            // Fall back to the previous conservative length check only when
            // unsaturation scores are equal.
            if (aromaticBestUnsat > longestAcyclicUnsat) {
              const chosen = fullyAromaticRingChains.filter(c => computeUnsaturationScore(c, molecule) === aromaticBestUnsat);
              if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: preferring fully-aromatic ring-union candidates (no principal FG - unsat greater):', chosen.map(c => c.join('-')), 'unsat=', aromaticBestUnsat, 'acyclicUnsat=', longestAcyclicUnsat, 'aromaticLen=', maxAromaticLen, 'acyclicLen=', longestAcyclicLen);
              return selectBestChain(chosen, molecule, 'No principal FG (fully-aromatic ring union unsat-preference)');
            }
            // If unsaturation ties, require aromatic ring union to be at least
            // as long as the longest acyclic chain (conservative tie-break).
            if (aromaticBestUnsat === longestAcyclicUnsat && maxAromaticLen >= longestAcyclicLen) {
              const chosen = fullyAromaticRingChains.filter(c => computeUnsaturationScore(c, molecule) === aromaticBestUnsat);
              if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: preferring fully-aromatic ring-union candidates (no principal FG - unsat tie, len >=):', chosen.map(c => c.join('-')), 'unsat=', aromaticBestUnsat);
              return selectBestChain(chosen, molecule, 'No principal FG (fully-aromatic ring union tie-break)');
            }
          }

           // Special-case: if the molecule's entire aromatic system is a single
           // ring (e.g., substituted benzene), and the longest acyclic path
           // traverses aromatic atoms, prefer the single aromatic ring parent
           // over a longer acyclic path that cuts through the ring. This must
           // be considered before the generic "prefer longest acyclic chain"
           // rule to avoid selecting long substituent-traversing paths.
           // HOWEVER: skip this special-case if there are ring-union candidates
           // that are significantly larger (> best single ring), as those likely
           // represent better polycyclic aromatic parents (e.g., naphthalene).
           try {
             const totalAromaticAtoms = molecule.atoms.reduce((acc, at) => acc + (at?.aromatic ? 1 : 0), 0);
             const aromaticSingleRingsEarly = ringChains.filter(c => c.length >= 3 && c.every(i => molecule.atoms[i]?.aromatic));
             if (aromaticSingleRingsEarly.length > 0 && totalAromaticAtoms > 0) {
               const bestAromaticEarly = aromaticSingleRingsEarly.reduce((a, b) => (computeUnsaturationScore(b, molecule) > computeUnsaturationScore(a, molecule) ? b : a));
               const longestAcyclicUsesAromaticEarly = acyclicChains.some(c => c.some(idx => molecule.atoms[idx]?.aromatic));
               
               // Check if there are larger ring-union candidates
               const bestRingUnionLen = ringChains.filter(c => c.length > bestAromaticEarly.length).length > 0
                 ? Math.max(...ringChains.filter(c => c.length > bestAromaticEarly.length).map(c => c.length))
                 : 0;
               
               // Only apply this special-case when:
               // 1. The best aromatic candidate matches a single SSSR ring
               // 2. The best aromatic ring represents the whole aromatic system
               // 3. There are no significantly larger ring-union candidates
               try {
                 const ringInfo = analyzeRings(molecule);
                 const sssrCarbonRings = (ringInfo.rings || []).map(r => r.filter((i: number) => molecule.atoms[i]?.symbol === 'C'));
                 const bestSet = new Set(bestAromaticEarly);
                 const matchesSingleSSSR = sssrCarbonRings.some(r => r.length === bestAromaticEarly.length && r.every(idx => bestSet.has(idx)));
                 if (matchesSingleSSSR && bestAromaticEarly.length === totalAromaticAtoms && longestAcyclicUsesAromaticEarly && bestRingUnionLen === 0) {
                   if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: special-case: preferring single aromatic ring that equals whole aromatic system (no principal FG):', bestAromaticEarly.join('-'));
                   return selectBestChain([bestAromaticEarly], molecule, 'No principal FG (single aromatic system preference)');
                 }
               } catch (e) {
                 // if ring analysis fails, be conservative and skip special-case
               }
             }
           } catch (e) {}

          // Prefer longest acyclic carbon path by default when it is at least as long
          // as any ring-based candidate. This enforces the convention of choosing
          // the longest carbon chain in aliphatic cases and avoids aggressive ring
          // preference for slightly longer ring unions.
          // HOWEVER: if the molecule contains alicyclic (non-aromatic) rings, prefer
          // ring-based parents by default (IUPAC P-44.1: "if a choice exists between
          // a cycloalkane and a non-cycloalkane parent chain, the cycloalkane is selected").
          // Only use acyclic paths for purely aliphatic molecules.
          const hasAlicyclicRings = ringInfo.rings && ringInfo.rings.length > 0 && ringInfo.rings.some(r => r.some(i => !molecule.atoms[i]?.aromatic));
          if (!hasAlicyclicRings && longestAcyclicLen >= bestRingLen && longestAcyclicLen > 0) {
            const acyclicTop = acyclicChains.filter(c => c.length === longestAcyclicLen);
            if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: preferring longest acyclic chain (no principal FG):', acyclicTop.map(c => c.join('-')));
            return selectBestChain(acyclicTop, molecule, 'No principal FG (prefer longest acyclic chain)');
          }

           // Prefer single aromatic ring parents for substituted aromatic
           // molecules only when the aromatic ring is at least as long as the
           // longest acyclic carbon path. This avoids selecting a single ring
           // in fused polycyclic systems (naphthalenes/phenanthrenes) where a
           // larger aromatic parent is expected.
           const aromaticSingleRings = ringChains.filter(c => c.length >= 3 && c.every(i => molecule.atoms[i]?.aromatic));
           if (aromaticSingleRings.length > 0) {
             const bestAromatic = aromaticSingleRings.reduce((a, b) => (computeUnsaturationScore(b, molecule) > computeUnsaturationScore(a, molecule) ? b : a));
             const bestAromaticUnsat = computeUnsaturationScore(bestAromatic, molecule);
             // Count total aromatic atoms in the molecule
             const totalAromaticAtoms = molecule.atoms.reduce((acc, at) => acc + (at?.aromatic ? 1 : 0), 0);
             // If the best single aromatic ring represents the entire aromatic system
             // (e.g., substituted benzene) and the longest acyclic path traverses
             // aromatic atoms, prefer the single ring parent. Otherwise fall back
             // to unsaturation/length-based checks.
             // HOWEVER: skip this if there are larger ring-union candidates (multiple aromatic rings fused),
             // as those likely represent better polycyclic aromatic parents.
             // Ring-union candidates are those with multiple aromatic atoms beyond the best single ring.
             const ringCount = molecule.atoms.length > 0 
               ? (analyzeRings(molecule).rings || []).filter(r => r.some(i => molecule.atoms[i]?.aromatic)).length 
               : 0;
             const hasLargerRingUnion = ringCount > 1 && ringChains.some(c => c.length > bestAromatic.length && c.some(idx => !bestAromatic.includes(idx)));
             const longestAcyclicUsesAromatic = acyclicChains.some(c => c.some(idx => molecule.atoms[idx]?.aromatic));
             if (!hasLargerRingUnion && ((bestAromatic.length === totalAromaticAtoms && longestAcyclicUsesAromatic) || bestAromaticUnsat > longestAcyclicUnsat || bestAromatic.length >= longestAcyclicLen)) {
               if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: preferring aromatic single-ring candidate (no principal FG):', bestAromatic.join('-'), 'unsat=', bestAromaticUnsat, 'acyclicUnsat=', longestAcyclicUnsat, 'totalAromatic=', totalAromaticAtoms);
               return selectBestChain([bestAromatic], molecule, 'No principal FG (aromatic single-ring preference)');
             }
           }

          // For alicyclic molecules, prefer ring-based parents even if acyclic is longer
          // (IUPAC P-44.1: "if a choice exists between a cycloalkane and a non-cycloalkane
          // parent chain, the cycloalkane is selected")
          if (hasAlicyclicRings && ringChains.length > 0) {
            const topRingCandidates = ringChains.filter(c => c.length === bestRingLen);
            if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: preferring ring-based candidates for alicyclic molecule (no principal FG):', topRingCandidates.map(c => c.join('-')));
            if (topRingCandidates.length === 1) return { chain: topRingCandidates[0]!, reason: 'Preferred ring-based candidate for alicyclic molecule (no principal FG)' };
            return selectBestChain(topRingCandidates, molecule, 'No principal FG (alicyclic ring preference)');
          }

          // For purely aliphatic molecules, only prefer ring-based candidates if they're
          // strictly longer than acyclic by at least 2 atoms (conservative approach).
          if (bestRingLen >= longestAcyclicLen + 2) {
            const topRingCandidates = ringChains.filter(c => c.length === bestRingLen);
            if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: preferring ring-based candidates (no principal FG):', topRingCandidates.map(c => c.join('-')));
            if (topRingCandidates.length === 1) return { chain: topRingCandidates[0]!, reason: 'Preferred ring-based candidate (no principal FG)' };
            return selectBestChain(topRingCandidates, molecule, 'No principal FG (ring preference)');
          }
         }
       } catch (e) {
         // ignore ring preference errors and continue to length-based fallback
       }

       // Always restrict to maxLenCandidates for highly branched alkanes (IUPAC compliance)
       if (maxLenCandidates.length === 1) return { chain: maxLenCandidates[0]!, reason: 'Only one chain candidate' };
       return selectBestChain(maxLenCandidates, molecule, 'No principal FG (max length only)');
    }

  // Instead of requiring the chain to literally contain the principal atom index (which
  // excludes ring-only parents for substituent-based functional groups like benzoic acid),
  // compute a per-chain functional group priority and prefer chains with the highest
  // chain-level priority. This allows ring parents that carry the functional group as a
  // substituent to be selected correctly.
  const chainPriorities = allCandidates.map(c => ({ chain: c, priority: getChainFunctionalGroupPriority(c, molecule) }));
  const maxChainPriority = Math.max(...chainPriorities.map(x => x.priority));

  if (maxChainPriority === 0) {
    // No chain-level functional group detected â€” fall back to full pipeline
    return selectBestChain(allCandidates, molecule, 'No principal FG at chain level');
  }

   // If the principal functional group is attached to a ring (e.g., benzoic acid),
   // prefer ring-origin candidates that are adjacent to the principal atom(s).
   // However, only do this if the ring candidates are reasonably long (within 1-2 atoms of the longest chain).
   try {
     const ringInfo = analyzeRings(molecule);
     if (ringInfo.rings.length > 0 && principalAtoms.length > 0) {
       // find ring-origin candidates among allCandidates
       const ringOriginCandidates = allCandidates.filter(c => c.every(i => ringInfo.getRingsContainingAtom(i).length > 0));
       if (ringOriginCandidates.length > 0) {
         // Find the longest among ring-origin candidates
         const maxRingLen = Math.max(...ringOriginCandidates.map(c => c.length));
         // Find the longest overall candidate
         const maxOverallLen = Math.max(...allCandidates.map(c => c.length));
         
         // Only prefer ring candidates if they're not significantly shorter than the longest overall chain
         // (allow up to 2 atoms difference to avoid strongly preferring rings over better aliphatic chains)
          if (maxRingLen >= maxOverallLen - 2) {
            if (process.env.VERBOSE) {
              console.log('[chain-selection] DEBUG: Checking ring adjacency to principal FG');
              console.log('[chain-selection] DEBUG: principalAtoms=', principalAtoms, 'maxRingLen=', maxRingLen, 'maxOverallLen=', maxOverallLen);
            }
            for (const p of principalAtoms) {
              const neighs = getNeighbors(p, molecule);
              if (process.env.VERBOSE) {
                console.log('[chain-selection] DEBUG: principal atom', p, 'neighbors=', neighs);
              }
              // if any neighbor of principal atom is part of a ring-origin candidate, prefer ring
              const near = ringOriginCandidates.filter(c => c.some(idx => neighs.includes(idx) || c.includes(p)));
              if (process.env.VERBOSE) {
                console.log('[chain-selection] DEBUG: near.length=', near.length, 'near=', near.map(c => c.join('-')));
              }
              if (near.length > 0) {
                if (process.env.VERBOSE) console.debug('[chain-selection] Preferring ring-origin candidate adjacent to principal FG', near.map(c => c.join('-')), 'maxRingLen=', maxRingLen, 'maxOverallLen=', maxOverallLen);
                const outcome = selectBestChain(near, molecule, 'Preferred ring-origin candidate due to principal FG adjacency');
                return { chain: outcome.chain, reason: outcome.reason || 'Preferred ring-origin candidate adjacent to FG' };
              }
            }
          }
       }
     }
   } catch (e) {
     // ignore
   }

  // If we have principal functional group atoms, ensure the longest carbon-only
  // path that contains any of these atoms is considered as a candidate. This
  // addresses cases where the enumerated acyclic candidates may miss a longer
  // chain that includes the functional group (important for acid-terminated
  // parents in tests). Keep this conservative: only prefer a principal-containing
  // longest path if it is strictly longer than existing candidates.
  try {
    if (principalAtoms.length > 0) {
      const enumerated = enumerateAllSimpleCarbonPaths(molecule, molecule.atoms.length || 12);
      if (process.env.VERBOSE) {
        try {
          console.debug('[chain-selection] VERBOSE: enumerated carbon paths (count=', enumerated.length, '):', enumerated.slice(0,20).map(p => ({ len: p.length, path: p })));
        } catch (e) {}
      }
      const withPrincipal = enumerated.filter(p => p.some(idx => principalAtoms.includes(idx)));
      if (withPrincipal.length > 0) {
        let best = withPrincipal[0]!;
        for (const p of withPrincipal) {
          if (p.length > best.length) best = p;
        }
        // Always include the best principal-containing path as a candidate so the
        // selector can prefer chains that contain the principal functional group
        // even when they are not strictly longer than other enumerated candidates.
        // This is a conservative change: we only add a single candidate (the best
        // principal-containing path) to the pool to give the selector more options
        // rather than forcing it to ignore plausible principal-containing chains.
        try {
          if (process.env.VERBOSE) console.debug('[chain-selection] VERBOSE: adding longest principal-containing carbon path (forced):', best);
        } catch (e) {}
        // Avoid adding duplicates
        try {
          const key = best.join(',');
          const exists = allCandidatesMap ? allCandidatesMap.has(key) : false;
          if (!exists) allCandidates.push(best);
        } catch (e) {
          // fallback: just push
          allCandidates.push(best);
        }
      }
    }
  } catch (e) {
    // ignore enumeration errors
  }

  // Among chains with maximum FG priority, prefer those where the principal
  // functional group atom(s) appear as terminal atoms (chain ends). This ensures
  // that carboxylic acids and similar terminal functional groups produce short
  // parent chains (e.g., propanoic/phenylacetic acid) instead of being subsumed by
  // a longer carbon path that merely passes through the FG atom internally.
  const principalAtomSet = new Set(principalAtoms);
  // Also detect carboxyl-like carbons (C with =O and -O) as principal atoms
  const carboxylAtomSet = new Set<number>();
  for (let i = 0; i < molecule.atoms.length; i++) {
    const atom = molecule.atoms[i];
    if (!atom || atom.symbol !== 'C') continue;
    const bonds = molecule.bonds.filter(b => b.atom1 === i || b.atom2 === i);
    let hasDoubleO = false;
    let hasSingleO = false;
    for (const b of bonds) {
      const neigh = b.atom1 === i ? b.atom2 : b.atom1;
      const nat = molecule.atoms[neigh];
      if (!nat) continue;
      if (nat.symbol === 'O') {
        if (b.type === BondType.DOUBLE) hasDoubleO = true;
        if (b.type === BondType.SINGLE) hasSingleO = true;
      }
    }
    if (hasDoubleO && hasSingleO) carboxylAtomSet.add(i);
  }

  if (process.env.VERBOSE) {
    try {
      console.debug('[chain-selection] principalAtoms:', principalAtoms);
      console.debug('[chain-selection] carboxylAtoms:', Array.from(carboxylAtomSet.values()));
    } catch (e) {}
  }
  const candidatesWithPriority = chainPriorities.filter(x => x.priority === maxChainPriority).map(x => x.chain);

  // Detect terminal-FG candidates
  const terminalCandidates = candidatesWithPriority.filter(c => {
    if (c.length === 0) return false;
    const first = c[0]!;
    const last = c[c.length - 1]!;
    return principalAtomSet.has(first) || principalAtomSet.has(last) || carboxylAtomSet.has(first) || carboxylAtomSet.has(last);
  });

  // Also detect candidates that contain a principal atom anywhere in the chain
  // (useful for ring-based chains where the principal FG is attached to an internal
  // ring atom rather than being a terminal atom).
  const principalContainingCandidates = candidatesWithPriority.filter(c => c.some(idx => principalAtomSet.has(idx) || carboxylAtomSet.has(idx)));

  if (process.env.VERBOSE) {
    try {
      console.debug('[chain-selection] candidatesWithPriority:', candidatesWithPriority.map(c => c.join('-')));
      console.debug('[chain-selection] terminalCandidates:', terminalCandidates.map(c => c.join('-')));
    } catch (e) {}
  }

  // If there are ring-origin candidates that are adjacent to the principal FG
  // (e.g., benzoic acid where the carboxyl is attached to the ring), prefer
  // those ring candidates before applying the terminal/aliphatic heuristics.
  try {
    const ringInfo = analyzeRings(molecule);
    const ringCandidates = candidatesWithPriority.filter(c => c.every(i => ringInfo.getRingsContainingAtom(i).length > 0));
    if (process.env.VERBOSE) {
      console.log('[chain-selection] DEBUG ringCandidates:', ringCandidates.map(c => c.join('-')));
      console.log('[chain-selection] DEBUG principalAtoms:', principalAtoms);
    }
    const ringCandidatesNearFG = ringCandidates.filter(c => {
      for (const p of principalAtoms) {
        // If principal atom itself is on the ring, prefer the ring candidate
        if (c.includes(p)) {
          if (process.env.VERBOSE) console.debug('[chain-selection] DEBUG: principal atom', p, 'is in ring candidate', c.join('-'));
          return true;
        }
        // If any neighbor of principal atom is part of the ring candidate, prefer it
        const neighs = getNeighbors(p, molecule);
        if (neighs.some(n => c.includes(n))) {
          if (process.env.VERBOSE) console.debug('[chain-selection] DEBUG: neighbor of principal atom', p, 'neighbors', neighs, 'found in ring candidate', c.join('-'));
          return true;
        }
      }
      return false;
    });
    if (ringCandidatesNearFG.length > 0) {
      if (process.env.VERBOSE) console.debug('[chain-selection] preferring ring candidates near FG:', ringCandidatesNearFG.map(c => c.join('-')));
      // prefer these ring candidates
      const outcome = selectBestChain(ringCandidatesNearFG, molecule, 'Preferred ring-origin candidate adjacent to FG');
      return { chain: outcome.chain, reason: outcome.reason || 'Preferred ring-origin candidate adjacent to FG' };
    }
  } catch (e) {
    // ignore ring-based preference errors and continue
  }

  // Prefer terminal candidates first, then any candidate that contains the principal
  // functional group anywhere (this lets ring parents win when they carry the FG as a
  // substituent). Fall back to all candidates with the top priority.
  const finalCandidates = terminalCandidates.length > 0 ? terminalCandidates : (principalContainingCandidates.length > 0 ? principalContainingCandidates : candidatesWithPriority);

  // Special-case: if the principal functional group is a high-priority suffix (e.g., carboxylic acid)
  // and we have terminal candidates, handle dicarboxylic acids correctly
  const CARBOXYL_PRIORITY_THRESHOLD = 6;
  if (process.env.VERBOSE) {
    console.debug('[chain-selection] Checking dicarboxylic acid condition:', { 
      terminalCandidatesLength: terminalCandidates.length,
      maxChainPriority,
      threshold: CARBOXYL_PRIORITY_THRESHOLD,
      conditionMet: terminalCandidates.length > 0 && maxChainPriority >= CARBOXYL_PRIORITY_THRESHOLD
    });
  }
  if (terminalCandidates.length > 0 && maxChainPriority >= CARBOXYL_PRIORITY_THRESHOLD) {
    // Handle dicarboxylic acids specially - detect ALL carboxylic acid carbons
    const allCarboxylCarbons = getAllCarboxylCarbons(molecule);
    if (process.env.VERBOSE) {
      console.debug('[chain-selection] All candidates:', allCandidates.map(c => ({ chain: c, length: c.length })));
    }
    if (allCarboxylCarbons.length > 1) {
      // For dicarboxylic acids, find the longest chain that includes both carboxyl groups
      // First try to find paths that include both carboxyl groups through ether linkages
      let extendedChain: number[] | null = null;
      
      // Calculate distances between all pairs of carboxyl carbons, including through ether linkages
      const distances = [];
      for (let i = 0; i < allCarboxylCarbons.length; i++) {
        for (let j = i + 1; j < allCarboxylCarbons.length; j++) {
          const path = findLongestPathWithEther(allCarboxylCarbons[i]!, allCarboxylCarbons[j]!, molecule);
          if (path.length > 0) {
            distances.push({ 
              from: allCarboxylCarbons[i]!, 
              to: allCarboxylCarbons[j]!, 
              path: path, 
              distance: path.length - 1 
            });
            
            // If this path is longer than current candidates, use it
            if (!extendedChain || path.length > extendedChain.length) {
              extendedChain = path;
            }
          }
        }
      }
      
      // Find candidate chains that contain both carboxyl carbons
      const carboxylChainCandidates = allCandidates.filter(chain => {
        const chainSet = new Set(chain);
        return allCarboxylCarbons.every(carb => chainSet.has(carb));
      });
      
      if (process.env.VERBOSE) {
        console.debug('[chain-selection] Dicarboxylic acid chain selection:', { 
          allCarboxylCarbons,
          carboxylChainCandidates: carboxylChainCandidates.map(c => ({ chain: c, length: c.length })),
          extendedChain,
          distances
        });
      }
      
      // Prefer the extended chain if it's longer and includes both carboxyls
      if (extendedChain && extendedChain.length >= 4) {
        const extendedChainSet = new Set(extendedChain);
        const hasBothCarboxyls = allCarboxylCarbons.every(carb => extendedChainSet.has(carb));
        if (hasBothCarboxyls) {
          if (process.env.VERBOSE) {
            console.debug('[chain-selection] Selected extended dicarboxylic chain through ether linkage:', extendedChain, 'length:', extendedChain.length);
          }
          const outcome = selectBestChain([extendedChain], molecule, `Preferred extended dicarboxylic acid chain (length ${extendedChain.length})`);
          return { chain: outcome.chain, reason: outcome.reason || `Preferred extended dicarboxylic acid chain (length ${extendedChain.length})` };
        }
      }
      
      if (carboxylChainCandidates.length > 0) {
        // Prefer the longest chain that contains both carboxyl groups
        let best = carboxylChainCandidates[0]!;
        for (const c of carboxylChainCandidates) {
          if (c.length > best.length) best = c;
        }
        
        if (process.env.VERBOSE) {
          console.debug('[chain-selection] Selected longest dicarboxylic chain:', best, 'length:', best.length);
        }
        
        const outcome = selectBestChain([best], molecule, `Preferred dicarboxylic acid chain (length ${best.length})`);
        return { chain: outcome.chain, reason: outcome.reason || `Preferred dicarboxylic acid chain (length ${best.length})` };
      }
    }

    // Continue with existing logic for monocarboxylic acids and fallback cases
    const ringInfo = analyzeRings(molecule);

    // Check if the principal functional group is on a linear aliphatic chain
    // that would make a better parent than the ring.
    // For phenylacetic acid: Ph-CH2-COOH â†’ 2 aliphatic carbons in a chain
    // For case 39: Ph-CH(CH3)-COOH â†’ 2 aliphatic carbons but branched
    // Rule: Prefer aliphatic if there are 2+ linear aliphatic carbons leading to FG
    const hasLinearAliphaticChain = terminalCandidates.some(c => {
      // Check if this is a pure aliphatic chain (no ring atoms)
      if (c.some(i => ringInfo.getRingsContainingAtom(i).length > 0)) return false;
      // Check if it contains at least 2 carbons and the FG
      if (c.length < 2) return false;
      // Check if it contains principal atoms
      if (!principalAtoms.some(p => c.includes(p))) return false;
      // Check if the non-FG carbons form a linear chain (each has max 2 carbon neighbors)
      const nonFGCarbons = c.filter(i => !principalAtoms.includes(i) && molecule.atoms[i]?.symbol === 'C');
      return nonFGCarbons.every(i => {
        const neighbors = getNeighbors(i, molecule);
        const carbonNeighbors = neighbors.filter(n => molecule.atoms[n]?.symbol === 'C');
        return carbonNeighbors.length <= 2;
      });
    });

    // Only prefer ring candidates if FG is directly on ring AND no good linear aliphatic chain exists
    const ringCandidatesNearFG = !hasLinearAliphaticChain ? terminalCandidates.filter(c => {
      // candidate is ring-origin if any atom is part of a ring
      const isRingOrigin = c.some(i => ringInfo.getRingsContainingAtom(i).length > 0);
      if (!isRingOrigin) return false;
      // check adjacency to any principal atom (principal atom itself or its neighbors)
      for (const p of principalAtoms) {
        if (c.includes(p)) return true;
        const neighs = getNeighbors(p, molecule);
        if (neighs.some(n => c.includes(n))) return true;
      }
      return false;
    }) : [];

    const aliphaticTerminal = terminalCandidates.filter(c => c.every(i => !molecule.atoms[i]?.aromatic && ringInfo.getRingsContainingAtom(i).length === 0));

    const pool = ringCandidatesNearFG.length > 0 ? ringCandidatesNearFG : (aliphaticTerminal.length > 0 ? aliphaticTerminal : terminalCandidates);

    // For high-priority FGs, prefer the longest chain that contains the FG (not the shortest)
    // This ensures dicarboxylic acids get the full backbone
    let best = pool[0]!;
    for (const c of pool) {
      const bestCarbons = countCarbons(best, molecule);
      const cCarbons = countCarbons(c, molecule);
      // Prefer longer chain for dicarboxylic acids
      if (cCarbons > bestCarbons) best = c;
      else if (cCarbons === bestCarbons && c.length > best.length) best = c;
    }
    // Run a final fine-grained selection among ties (if any) using existing selector to build reason
    const tied = pool.filter(c => countCarbons(c, molecule) === countCarbons(best, molecule) && c.length === best.length);
    const outcome = selectBestChain(tied.length > 0 ? tied : [best], molecule, 'Preferred longest terminal chain for high-priority FG');
    return { chain: outcome.chain, reason: outcome.reason || 'Preferred longest terminal chain for high-priority FG' };
  }

  

  const bestOutcome = selectBestChain(finalCandidates, molecule, terminalCandidates.length > 0 ? 'Contains principal FG at terminal' : 'Contains principal FG (chain-level)');
  return { chain: bestOutcome.chain, reason: bestOutcome.reason || 'Selected chain by chain-level FG priority' };
 }

/**
 * Check if an atom is directly part of a functional group (not just adjacent to it).
 * For carboxylic acids: only the carboxyl carbon and its bonded O atoms.
 * For other functional groups: only atoms that are integral to the group structure.
 */
function isAtomPartOfFunctionalGroup(idx: number, molecule: Molecule): boolean {
  const atom = molecule.atoms[idx];
  if (!atom) return false;

  // For oxygen atoms, check if they're bonded to a functional group carbon
  if (atom.symbol === 'O') {
    const bonds = molecule.bonds.filter(b => b.atom1 === idx || b.atom2 === idx);
    for (const b of bonds) {
      const neigh = b.atom1 === idx ? b.atom2 : b.atom1;
      const nat = molecule.atoms[neigh];
      if (!nat || nat.symbol !== 'C') continue;
      
      // Check if this carbon has a carbonyl (C=O pattern)
      const hasCarbonyl = molecule.bonds.some(cb => {
        if ((cb.atom1 !== neigh && cb.atom2 !== neigh) || cb.type !== BondType.DOUBLE) return false;
        const other = cb.atom1 === neigh ? cb.atom2 : cb.atom1;
        return molecule.atoms[other]?.symbol === 'O';
      });
      if (hasCarbonyl) return true;
    }
    return false;
  }

  // For carbon atoms, check if they're the functional group carbon itself
  if (atom.symbol === 'C') {
    const bonds = molecule.bonds.filter(b => b.atom1 === idx || b.atom2 === idx);
    
    let hasDoubleO = false;
    let hasSingleOwithH = false;
    let hasSingleO = false;
    let hasSingleN = false;
    let hasCl = false;
    let hasTripleN = false;

    for (const b of bonds) {
      const neigh = b.atom1 === idx ? b.atom2 : b.atom1;
      const nat = molecule.atoms[neigh];
      if (!nat) continue;

      if (nat.symbol === 'O') {
        if (b.type === BondType.DOUBLE) hasDoubleO = true;
        if (b.type === BondType.SINGLE) {
          hasSingleO = true;
          if ((nat as any).hydrogens && (nat as any).hydrogens > 0) hasSingleOwithH = true;
        }
      }
      if (nat.symbol === 'N' && b.type === BondType.SINGLE) hasSingleN = true;
      if (nat.symbol === 'N' && b.type === BondType.TRIPLE) hasTripleN = true;
      if (nat.symbol === 'Cl' && b.type === BondType.SINGLE) hasCl = true;
    }

    // Check if this carbon is a functional group carbon
    // Carboxylic acid, ester, amide, acid chloride, ketone, aldehyde, nitrile
    if (hasTripleN) return true; // Nitrile
    if (hasDoubleO && (hasSingleOwithH || hasSingleO || hasSingleN || hasCl)) return true; // Carboxyl derivatives
    if (hasDoubleO) return true; // Ketone/aldehyde
    
    return false;
  }

  // For nitrogen, sulfur, phosphorus in functional groups
  if (atom.symbol === 'N' || atom.symbol === 'S' || atom.symbol === 'P') {
    // These atoms in functional groups are typically bonded to O or involved in special bonding
    const bonds = molecule.bonds.filter(b => b.atom1 === idx || b.atom2 === idx);
    for (const b of bonds) {
      const neigh = b.atom1 === idx ? b.atom2 : b.atom1;
      const nat = molecule.atoms[neigh];
      if (nat?.symbol === 'O') return true;
    }
  }

  return false;
}

/**
 * Compute per-atom principal functional group indices.
 * Returns only atoms that are directly part of the functional group structure,
 * not atoms that are merely adjacent to a functional group.
 */
function getPrincipalFunctionalGroupAtoms(molecule: Molecule): number[] {
  let bestPriority = 0;
  const priorMap = new Map<number, number>();
  
  // First pass: find the highest priority functional group in the molecule
  for (let i = 0; i < molecule.atoms.length; i++) {
    const atom = molecule.atoms[i];
    if (!atom) continue;
    const p = getChainFunctionalGroupPriority([i], molecule);
    priorMap.set(i, p);
    if (p > bestPriority) bestPriority = p;
  }
  
  if (bestPriority === 0) return [];
  
  // Second pass: only include atoms that are directly part of the functional group
  const result: number[] = [];
  for (const [idx, p] of priorMap) {
    if (p === bestPriority && isAtomPartOfFunctionalGroup(idx, molecule)) {
      result.push(idx);
    }
  }
  
  return result;
}

/**
 * Compare two chains according to the requested policy.
 * Returns -1 if b is better than a, 1 if a is better, 0 if equal.
 */
function compareChainsPreferPrincipal(a: number[], b: number[], molecule: Molecule): number {
  // Calculate locants for both chains
  const aLocants = getSubstituentLocants(a, molecule).slice().sort((x, y) => x - y);
  const bLocants = getSubstituentLocants(b, molecule).slice().sort((x, y) => x - y);

  // 1) Longest carbon chain (count carbon atoms)
  const aCarbons = countCarbons(a, molecule);
  const bCarbons = countCarbons(b, molecule);
  // IUPAC tie-breaking: when two chains differ in carbon count, prefer the
  // longer chain in general. However, when the difference is only one carbon,
  // the chain with the greater number of substituents (more highly substituted)
  // may be preferred because it maximizes substituent count on the parent.
  // Therefore, if the carbon-count difference is exactly 1, prefer the chain
  // that has strictly more substituent positions.
  const aSubsEst = getSubstituentLocants(a, molecule).length;
  const bSubsEst = getSubstituentLocants(b, molecule).length;
  if (bCarbons > aCarbons) {
    const diff = bCarbons - aCarbons;
    if (diff === 1 && aSubsEst >= bSubsEst) {
      // prefer a (shorter but more substituted)
      return 1;
    }
    return -1;
  }
  if (bCarbons < aCarbons) {
    const diff = aCarbons - bCarbons;
    if (diff === 1 && bSubsEst >= aSubsEst) {
      // prefer b (shorter but more substituted)
      return -1;
    }
    return 1;
  }

  // 2) More substituents (count substituent positions)
  const aSubs = aLocants.length;
  const bSubs = bLocants.length;
  if (bSubs > aSubs) return -1;
  if (bSubs < aSubs) return 1;

  // 3) If equal carbon count, prefer the longer total atom chain (tie-breaker)
  if (b.length > a.length) return -1;
  if (b.length < a.length) return 1;

  // 4) Prefer the set of locants that is lower (IUPAC lowest-set rule)
  if (isLowerLocants(bLocants, aLocants)) return -1;
  if (isLowerLocants(aLocants, bLocants)) return 1;

  // 5) Alphabetically smaller substituents
  const aLabels = getSubstituentLabels(a, molecule).sort();
  const bLabels = getSubstituentLabels(b, molecule).sort();
  const len = Math.min(aLabels.length, bLabels.length);
  for (let i = 0; i < len; i++) {
    if (aLabels[i]! < bLabels[i]!) return 1; // a is alphabetically smaller -> a better
    if (aLabels[i]! > bLabels[i]!) return -1;
  }
  if (aLabels.length < bLabels.length) return -1; // b has extra labels -> b better
  if (aLabels.length > bLabels.length) return 1;

  return 0;
}

/**
 * Build simple substituent labels for each substituent attached to a chain.
 * Label is constructed by taking the atom symbol of the substituent root plus a small
 * fingerprint of its immediate neighborhood (up to depth 2), joined as a string.
 */
function getSubstituentLabels(chain: number[], molecule: Molecule): string[] {
  const labels: string[] = [];
  const chainSet = new Set(chain);
  for (let i = 0; i < chain.length; i++) {
    const atomIdx = chain[i]!;
    const neighbors = getNeighbors(atomIdx, molecule);
    for (const neigh of neighbors) {
      if (chainSet.has(neigh)) continue;
      // Build small fingerprint
      const seen = new Set<number>();
      const parts: string[] = [];
      const queue: number[] = [neigh];
      let depth = 0;
      while (queue.length > 0 && depth < 2) {
        const levelSize = queue.length;
        for (let j = 0; j < levelSize; j++) {
          const n = queue.shift()!;
          if (seen.has(n)) continue;
          seen.add(n);
          const nat = molecule.atoms[n];
          if (!nat) continue;
          parts.push(nat.symbol + (nat.aromatic ? 'a' : ''));
          for (const nb of getNeighbors(n, molecule)) {
            if (!seen.has(nb) && !chainSet.has(nb)) queue.push(nb);
          }
        }
        depth++;
      }
      labels.push(parts.join('-'));
    }
  }
  return labels;
}

/**
 * Extend a ring chain through a substituent carbon.
 * Only extends linearly (through atoms with 2 bonds) to form longer principal chains.
 * Returns chains that extend 1-2 atoms deep into the substituent.
 */
function extendRingThroughSubstituent(
  ringAtom: number,
  substituent: number,
  ring: number[],
  molecule: Molecule,
  excludeSet: Set<number>
): number[][] {
  const extensions: number[][] = [];
  
  // Do not extend through functional group carbons
  // When a carboxylic acid (-COOH) is attached to a ring, the ring should be the parent
  // with "-carboxylic acid" suffix, not an extended chain including the -COOH carbon
  if (isAtomPartOfFunctionalGroup(substituent, molecule)) {
    return extensions; // return empty - no extension through functional groups
  }
  
  // Only extend if substituent has â‰¤ 2 carbon neighbors (linear extension)
  const substituentNeighbors = getNeighbors(substituent, molecule)
    .filter(n => molecule.atoms[n]?.symbol === 'C' && !excludeSet.has(n));
  
  // Also check if any of the substituent's neighbors are functional group carbons
  // If so, don't extend through this substituent (e.g., -CH(CH3)-COOH should not extend)
  const hasFunctionalGroupNeighbor = substituentNeighbors.some(n => 
    isAtomPartOfFunctionalGroup(n, molecule)
  );
  if (hasFunctionalGroupNeighbor) {
    return extensions; // don't extend if substituent has functional group attached
  }
  
  // Extend 1 atom: ring + substituent
  extensions.push([...ring, substituent]);
  
  // Extend 2 atoms: ring + substituent + one more (if it's linear)
  if (substituentNeighbors.length === 1) {
    // substituent is terminal in the substituent branch (only bonds to ring via ringAtom)
    const next = substituentNeighbors[0]!;
    
    // Also don't extend through functional group carbons in the next position
    if (isAtomPartOfFunctionalGroup(next, molecule)) {
      return extensions; // stop extending here
    }
    
    const nextNeighbors = getNeighbors(next, molecule)
      .filter(n => molecule.atoms[n]?.symbol === 'C' && n !== substituent && !excludeSet.has(n));
    
    if (nextNeighbors.length <= 1) {
      // next is also on a linear path, extend one more
      extensions.push([...ring, substituent, next]);
      
      // Optionally extend to 3 atoms if the path continues linearly
      if (nextNeighbors.length === 1) {
        const next2 = nextNeighbors[0]!;
        
        // Also check next2 for functional groups
        if (isAtomPartOfFunctionalGroup(next2, molecule)) {
          return extensions; // stop extending here
        }
        
        const next2Neighbors = getNeighbors(next2, molecule)
          .filter(n => molecule.atoms[n]?.symbol === 'C' && n !== next && !excludeSet.has(n));
        if (next2Neighbors.length <= 1) {
          extensions.push([...ring, substituent, next, next2]);
        }
      }
    }
  }
  
  return extensions;
}

/**
 * Generate chain candidates based on ring topology.
 * - Includes individual SSSR rings (carbon-only atom lists)
 * - Includes unions of two rings (for fused/spiro/bridged systems) as candidate chains
 */
function findRingBasedChains(molecule: Molecule): number[][] {
  const ringInfo = analyzeRings(molecule);
  const rings = ringInfo.rings || [];
  const candidates: number[][] = [];
  // Debug: log rings detected for troubleshooting
  if (process.env.VERBOSE) {
    try {
      console.debug('[chain-selection] findRingBasedChains: detected rings:', rings.map(r => r.join('-')));
    } catch (e) {}
  }

   // Single-ring candidates (carbon-only)
   for (let ringIdx = 0; ringIdx < rings.length; ringIdx++) {
     const ring = rings[ringIdx]!;
     const carbons = ring.filter(i => molecule.atoms[i]?.symbol === 'C');
     if (carbons.length >= 3) {
       candidates.push(carbons);
       if (process.env.VERBOSE) {
         try {
           console.debug('[chain-selection] findRingBasedChains: adding single-ring candidate:', carbons.join('-'));
         } catch (e) {}
       }
       
        // For each ring atom, try extending through substituent carbons to form longer chains
         // (IUPAC allows ring-based parents to include substituent carbons if they form a longer chain)
         // BUT: 
         // - Don't extend aromatic rings (substituents are named separately as prefixes)
         // - Don't extend through atoms that are themselves ring members of OTHER rings (handled by ring unions)
         const isAromaticRing = carbons.some(idx => molecule.atoms[idx]?.aromatic);
         if (!isAromaticRing) {
           const ringSet = new Set(carbons);
           const otherRingAtoms = new Set<number>();
           for (let k = 0; k < rings.length; k++) {
             if (k !== ringIdx) {
               for (const atom of rings[k]!) {
                 otherRingAtoms.add(atom);
               }
             }
           }
           for (const ringAtom of carbons) {
             const neighbors = getNeighbors(ringAtom, molecule);
             for (const neighbor of neighbors) {
               if (!ringSet.has(neighbor) && !otherRingAtoms.has(neighbor) && molecule.atoms[neighbor]?.symbol === 'C') {
                // This is a substituent carbon (not part of any ring) attached to this ring
                // Try extending through it (up to 2 more atoms) to form longer chains
                const extended = extendRingThroughSubstituent(ringAtom, neighbor, carbons, molecule, new Set(carbons));
                for (const ext of extended) {
                  if (ext.length > carbons.length) {
                    candidates.push(ext);
                    if (process.env.VERBOSE) {
                      try {
                        console.debug('[chain-selection] findRingBasedChains: adding extended-ring candidate:', ext.join('-'));
                      } catch (e) {}
                    }
                  }
                }
               }
             }
           }
         }
     }
   }

   // Pairwise unions for fused/spiro/bridged systems
   for (let i = 0; i < rings.length; i++) {
     for (let j = i + 1; j < rings.length; j++) {
       const ringA = rings[i]!;
       const ringB = rings[j]!;
       // Compute carbon-only counts for rings and their union so heteroatom-containing
       // rings don't cause incorrect skipping of viable carbon unions.
       const ringACarbons = ringA.filter(i => molecule.atoms[i]?.symbol === 'C');
       const ringBCarbons = ringB.filter(i => molecule.atoms[i]?.symbol === 'C');
       const unionSet = new Set<number>([...ringACarbons, ...ringBCarbons]);
       const unionCarbons = Array.from(unionSet);
       // Only consider if union expands beyond individual carbon-only rings
       if (unionCarbons.length > Math.max(ringACarbons.length, ringBCarbons.length) && unionCarbons.length >= 3) {
         candidates.push(unionCarbons);
         if (process.env.VERBOSE) {
           try {
             console.debug('[chain-selection] findRingBasedChains: adding union candidate:', unionCarbons.join('-'));
           } catch (e) {}
         }
       } else {
         if (process.env.VERBOSE) {
           try {
             console.debug('[chain-selection] findRingBasedChains: skipping union (not larger):', unionCarbons.join('-'));
           } catch (e) {}
         }
       }
     }
   }

   // For polycyclic systems with 3+ rings, also consider the union of all rings
   if (rings.length >= 3) {
     const allRingsCarbons = new Set<number>();
     for (const ring of rings) {
       for (const atom of ring) {
         if (molecule.atoms[atom]?.symbol === 'C') {
           allRingsCarbons.add(atom);
         }
       }
     }
     const allUnionCarbons = Array.from(allRingsCarbons);
     if (allUnionCarbons.length >= 3) {
       // Check if this union is longer than any existing candidate
       const existingMax = candidates.length > 0 ? Math.max(...candidates.map(c => c.length)) : 0;
       if (allUnionCarbons.length > existingMax) {
         candidates.push(allUnionCarbons);
         if (process.env.VERBOSE) {
           try {
             console.debug('[chain-selection] findRingBasedChains: adding all-rings union candidate:', allUnionCarbons.join('-'));
           } catch (e) {}
         }
       }
     }
   }

  // Deduplicate by sorted key
  const unique = new Map<string, number[]>();
  for (const c of candidates) {
    const key = [...c].sort((a, b) => a - b).join(',');
    const existing = unique.get(key);
    if (!existing || c.length > existing.length) unique.set(key, c);
  }

  return Array.from(unique.values()).sort((a, b) => b.length - a.length);
}

/**
 * Select the best chain from a list of candidate chains.
 */
function selectBestChain(chains: number[][], molecule: Molecule, prefix: string): ChainSelectionResult {
  if (chains.length === 0) {
    return { chain: [], reason: 'No chains found' };
  }

  if (chains.length === 1) {
    return { chain: chains[0]!, reason: prefix || 'Only one chain found' };
  }

  // Convert numeric chains (number[] of atom indices) into Chain objects expected by ChainSelector
  const converted: Chain[] = chains.map(c => {
    const isAromatic = c.some(i => molecule.atoms[i]?.aromatic);

    // Determine functional group priority on this chain
    const fgPriority = getChainFunctionalGroupPriority(c, molecule);

    // Populate a lightweight functionalGroups array so filters can detect presence
    const functionalGroups = fgPriority > 0 ? [{ functionalGroup: { name: 'principal', priority: fgPriority, smarts: '', suffix: '', parenthesized: false, atomIndices: [], isPrincipal: true } as any, position: 1, count: 1 }] : [];

    // Determine substituent positions (simple count)
    const locants = getSubstituentLocants(c, molecule);
    const substituents = locants.map(l => ({ position: String(l), type: 'alkyl', size: 1, name: 'alkyl' }));

    // Rough cycle detection: if any atom in chain is part of a ring (via analyzeRings), mark cyclic
    const ringInfo = analyzeRings(molecule);
    const isCyclic = c.some(i => ringInfo.getRingsContainingAtom(i).length > 0);

    // Mark if this numeric chain exactly matches a single SSSR ring or a union of rings
    let isFromRingUnion = false;
    try {
      // Use carbon-only ring sets so the ring-origin hint is consistent with
      // chain candidates (which are carbon-only lists).
      const sets = ringInfo.rings.map(r => new Set(r.filter((x: number) => molecule.atoms[x]?.symbol === 'C')));
      // exact match to a ring (carbon-only)
      for (const s of sets) {
        if (s.size === c.length && c.every(idx => s.has(idx))) {
          isFromRingUnion = true;
          break;
        }
      }
      // check union of any two carbon-only rings
      if (!isFromRingUnion) {
        for (let i = 0; i < sets.length; i++) {
          for (let j = i + 1; j < sets.length; j++) {
            const union = new Set<number>();
            for (const v of sets[i]!) union.add(v);
            for (const v of sets[j]!) union.add(v);
            if (union.size === c.length && c.every(idx => union.has(idx))) {
              isFromRingUnion = true;
              break;
            }
          }
          if (isFromRingUnion) break;
        }
      }
    } catch (e) {
      isFromRingUnion = false;
    }

    return {
      atomIndices: c,
      length: c.length,
      substituents,
      functionalGroups: functionalGroups as any,
      isCyclic,
      isAromatic,
      // attach ring-origin hint for downstream filters (cast to any to avoid strict type errors)
      ...(isFromRingUnion ? { isFromRingUnion: true } : {}),
    } as Chain;
  });

  const selector = createDefaultChainSelector();
  if (process.env.VERBOSE) {
    try {
      console.debug('[chain-selection] selectBestChain: converted candidates:', converted.map(c => ({ len: c.length, atomIndices: c.atomIndices, isCyclic: c.isCyclic, isAromatic: c.isAromatic, isFromRingUnion: (c as any).isFromRingUnion || false })));
    } catch (e) {}
  }
  const outcome = selector.selectBestChain(converted, { allChains: converted, moleculeData: { molecule } });
  if (process.env.VERBOSE) {
    try {
      // Log selected chain indices and full filter results for deep debugging
      const selectedIndices = outcome.selectedChain?.atomIndices ?? null;
      const filterResultsObj: Record<string, any> = {};
      for (const [k, v] of outcome.filterResults) {
        filterResultsObj[k] = v.map(t => ({ passes: t.result.passes, score: t.result.score, reason: t.result.reason }));
      }
      // Use JSON.stringify to ensure nested objects are fully printed in VERBOSE runs
      try {
        console.debug('[chain-selection] selector outcome:', JSON.parse(JSON.stringify({ selectedLen: outcome.selectedChain?.length ?? null, selectedIndices, reason: outcome.reason, filterResults: filterResultsObj })));
      } catch (e) {
        // Fallback to plain debug if stringify fails
        console.debug('[chain-selection] selector outcome:', { selectedLen: outcome.selectedChain?.length ?? null, selectedIndices, reason: outcome.reason, filterResults: filterResultsObj });
      }
    } catch (e) {}
  }

  if (outcome.selectedChain) {
    return { chain: outcome.selectedChain.atomIndices, reason: prefix || outcome.reason };
  }

  return { chain: chains[0]!, reason: prefix || 'Defaulted to first candidate' };
}

/**
 * Find all acyclic chains in a molecule.
 * An acyclic chain is a path through the graph where we don't revisit atoms.
 * For molecules with functional groups, chains can pass through aromatic rings,
 * which then become substituents on the main chain.
 * 
 * IUPAC rule: The main chain must consist of CARBON ATOMS ONLY.
 * Heteroatoms (O, N, etc.) are included as functional groups, not as chain atoms.
 */
function findAllAcyclicChains(molecule: Molecule): number[][] {
    const ringInfo = analyzeRings(molecule);
    const ringAtoms = new Set<number>();
    const aliphaticAtoms = new Set<number>();
    
    // Classify atoms as aromatic or aliphatic
    // IMPORTANT: Only include CARBON atoms in the main chain
    for (let i = 0; i < molecule.atoms.length; i++) {
      const atom = molecule.atoms[i]!;
      // Main chain must be carbon atoms
      if (atom.symbol !== 'C') continue;
      
      if (ringInfo.getRingsContainingAtom(i).length > 0) {
        ringAtoms.add(i);
        if (!atom.aromatic) {
          aliphaticAtoms.add(i);
        }
      } else {
        aliphaticAtoms.add(i);
      }
    }

   const chains: number[][] = [];
   const visited = new Set<number>();

   // Strategy: Find chains that stay in aliphatic regions, but can pass through
   // aromatic rings if necessary to connect functional groups.
   
   // Start DFS from each aliphatic atom to find the longest paths
   for (let startAtom = 0; startAtom < molecule.atoms.length; startAtom++) {
     if (!aliphaticAtoms.has(startAtom)) continue;
     visited.clear();
     const chain: number[] = [];
     dfsMaxChain(startAtom, molecule, visited, chain, chains, aliphaticAtoms);
   }

   // Remove duplicates and sub-chains
   const uniqueChains = new Map<string, number[]>();
   for (const chain of chains) {
     const key = [...chain].sort((a, b) => a - b).join(',');
     const existing = uniqueChains.get(key);
     if (!existing || chain.length > existing.length) {
       uniqueChains.set(key, chain);
     }
   }

    // Also ensure we include the longest carbon-only path found globally as a candidate
    try {
      const longest = computeLongestCarbonPath(molecule);
      if (longest.length >= 2) {
        const canonicalLongest = canonicalizeAcyclicChainOrder(longest, molecule);
        const key = [...canonicalLongest].sort((a, b) => a - b).join(',');
        if (!uniqueChains.has(key)) uniqueChains.set(key, canonicalLongest);
      }
    } catch (e) {
      // ignore
    }

// Also enumerate all simple carbon-only paths (bounded) and include them as candidates
     try {
       const enumerated = enumerateAllSimpleCarbonPaths(molecule, 12);
       if (process.env.VERBOSE) {
         console.debug('[chain-selection] Enumerated paths:', enumerated.map(p => ({ path: p, length: p.length })));
       }
       for (const p of enumerated) {
         if (p.length < 2) continue;
         const key = [...p].sort((a, b) => a - b).join(',');
         if (!uniqueChains.has(key)) uniqueChains.set(key, p);
       }
     } catch (e) {
       // ignore
     }

    // Sort by length descending
    return Array.from(uniqueChains.values()).sort((a, b) => b.length - a.length);
 }

/**
 * Find chains that include heteroatoms as part of characteristic functional groups.
 * This handles amides, esters, and other compounds where N, O, S, etc. are part of
 * the principal chain definition.
 *
 * Returns chains as arrays of atom indices (both C and heteroatoms), but filters
 * to only count carbons for chain length.
 */
function findHeteroatomChains(molecule: Molecule): number[][] {
   const chains: number[][] = [];
   const visited = new Set<number>();

    // Find heteroatoms that are part of functional groups
    // Currently handles: amides (N) and anhydrides (O between two carbonyls)
    const heteroFunctionalAtoms = new Set<number>();
    
    // First, identify heteroatoms that should NEVER be traversed because they
    // represent the functional group itself (anhydrides, imides)
    const heteroAtomsToSkip = new Set<number>();
    
     for (let i = 0; i < molecule.atoms.length; i++) {
       const atom = molecule.atoms[i];
       if (!atom) continue;
       
       // Check for amide nitrogen (N bonded to one or more carbonyl carbons)
       if (atom.symbol === 'N') {
         const bonds = molecule.bonds.filter(b => b.atom1 === i || b.atom2 === i);
         const carbonylNeighbors: number[] = [];
         
         for (const bond of bonds) {
           const neighborIdx = bond.atom1 === i ? bond.atom2 : bond.atom1;
           const neighbor = molecule.atoms[neighborIdx];
           
           if (neighbor?.symbol === 'C') {
             // Check if this carbon has a C=O bond
             const carbonBonds = molecule.bonds.filter(b => b.atom1 === neighborIdx || b.atom2 === neighborIdx);
             const hasDoubleBondToO = carbonBonds.some(b => {
               const otherIdx = b.atom1 === neighborIdx ? b.atom2 : b.atom1;
               const otherAtom = molecule.atoms[otherIdx];
               return b.type === BondType.DOUBLE && otherAtom?.symbol === 'O';
             });
             
             if (hasDoubleBondToO) {
               carbonylNeighbors.push(neighborIdx);
             }
           }
         }
         
         // If this nitrogen is bonded to TWO carbonyl carbons, it's an imide
         // Skip it entirely - the principal chain is just 2 (the two carbonyl carbons separately)
         if (carbonylNeighbors.length >= 2) {
           heteroAtomsToSkip.add(i);
         } else if (carbonylNeighbors.length === 1) {
           // Single carbonyl attachment: regular amide - allow chain traversal
           heteroFunctionalAtoms.add(i);
         }
       }
       
       // Check for anhydride oxygens (O bonded to TWO carbonyl carbons)
       if (atom.symbol === 'O') {
         const bonds = molecule.bonds.filter(b => b.atom1 === i || b.atom2 === i);
         const carbonylNeighbors: number[] = [];
         
         for (const bond of bonds) {
           // Anhydride oxygen is bonded via single bonds to carbonyl carbons
           if (bond.type === BondType.SINGLE) {
             const neighborIdx = bond.atom1 === i ? bond.atom2 : bond.atom1;
             const neighbor = molecule.atoms[neighborIdx];
             
             if (neighbor?.symbol === 'C') {
               // Check if this carbon has a C=O bond (is it a carbonyl?)
               const carbonBonds = molecule.bonds.filter(b => b.atom1 === neighborIdx || b.atom2 === neighborIdx);
               const hasDoubleBondToO = carbonBonds.some(b => {
                 const otherIdx = b.atom1 === neighborIdx ? b.atom2 : b.atom1;
                 const otherAtom = molecule.atoms[otherIdx];
                 return b.type === BondType.DOUBLE && otherAtom?.symbol === 'O';
               });
               
               if (hasDoubleBondToO) {
                 carbonylNeighbors.push(neighborIdx);
               }
             }
           }
         }
         
         // If this oxygen is bonded to TWO carbonyl carbons, it's an anhydride oxygen
         // Skip it entirely - the principal chain is just 2 (the two carbonyl carbons separately)
         if (carbonylNeighbors.length >= 2) {
           heteroAtomsToSkip.add(i);
         }
         // NOTE: We do NOT add single-carbonyl ester oxygens to heteroFunctionalAtoms
         // because they are just substituents, not chain extensions. Simple esters like -OCH3
         // should not build heteroatom chains.
       }
      }

   // If we found heteroatoms or need to skip some, build chains that include valid heteroatoms
   if (heteroFunctionalAtoms.size === 0) {
     return chains;
   }

   // Build chains that pass through heteroatoms (but NOT those marked to skip)
   for (let start = 0; start < molecule.atoms.length; start++) {
     const atom = molecule.atoms[start];
     if (!atom || atom.symbol !== 'C') continue;
     
     visited.clear();
     const chain: number[] = [];
     dfsHeteroChain(start, molecule, visited, chain, chains, heteroFunctionalAtoms, heteroAtomsToSkip);
   }

  // Extract only the carbons from each chain but keep the full atom paths
  const carbonOnlyChains: number[][] = [];
  for (const chain of chains) {
    const carbons = chain.filter(idx => molecule.atoms[idx]?.symbol === 'C');
    if (carbons.length >= 2) {
      // Only add if it's a new chain (by carbon content)
      const key = [...carbons].sort((a, b) => a - b).join(',');
      const exists = carbonOnlyChains.some(c => [...c].sort((a, b) => a - b).join(',') === key);
      if (!exists) {
        carbonOnlyChains.push(carbons);
      }
    }
  }

  return carbonOnlyChains.sort((a, b) => b.length - a.length);
}

/**
 * DFS helper to build chains that include heteroatom functional groups.
 * For ester oxygens, we stop and don't traverse to the alcohol part.
 * For amide nitrogens, we continue through them to get the full chain.
 * Never traverses through heteroatoms in heteroAtomsToSkip (imides, anhydrides).
 */
function dfsHeteroChain(
   atom: number,
   molecule: Molecule,
   visited: Set<number>,
   currentChain: number[],
   allChains: number[][],
   heteroAtoms: Set<number>,
   heteroAtomsToSkip: Set<number> = new Set()
): void {
   visited.add(atom);
   currentChain.push(atom);

   // Record this chain if it contains heteroatoms
   if (currentChain.length >= 2 && currentChain.some(idx => heteroAtoms.has(idx))) {
     allChains.push([...currentChain]);
   }

   const neighbors = getNeighbors(atom, molecule);
   for (const nb of neighbors) {
     if (visited.has(nb)) continue;
     
     // Skip heteroatoms that are part of anhydrides/imides
     if (heteroAtomsToSkip.has(nb)) continue;
     
     const nbAtom = molecule.atoms[nb];
     
     // For heteroatoms, differentiate between amides (N) and esters (O)
     if (heteroAtoms.has(nb)) {
       const heteroSymbol = molecule.atoms[nb]?.symbol;
       if (heteroSymbol === 'N') {
         // For amides: traverse through nitrogen to continue the chain
         dfsHeteroChain(nb, molecule, visited, currentChain, allChains, heteroAtoms, heteroAtomsToSkip);
       } else if (heteroSymbol === 'O') {
         // For ester oxygens: include the oxygen in the chain
         visited.add(nb);
         currentChain.push(nb);
         // Record the chain after adding ester oxygen
         if (currentChain.length >= 2) {
           allChains.push([...currentChain]);
         }
         
         // Check if we should traverse beyond the oxygen:
         // - If the next atom is a carbonyl carbon (part of anhydride/mixed acid-ester), continue
         // - Otherwise (simple alkoxy like -OCH3), stop
         const oxygenNeighbors = getNeighbors(nb, molecule);
         let shouldContinue = false;
         for (const nextNb of oxygenNeighbors) {
           if (visited.has(nextNb) || nextNb === atom) continue;  // Skip visited or parent
           if (heteroAtomsToSkip.has(nextNb)) continue;  // Skip anhydride carbonyls
           if (molecule.atoms[nextNb]?.symbol === 'C') {
             // Check if this carbon is a carbonyl carbon (has a double bond to O)
             const carbonBonds = molecule.bonds.filter(b => b.atom1 === nextNb || b.atom2 === nextNb);
             const hasDoubleBondToO = carbonBonds.some(b => {
               const otherIdx = b.atom1 === nextNb ? b.atom2 : b.atom1;
               return b.type === BondType.DOUBLE && molecule.atoms[otherIdx]?.symbol === 'O';
             });
             if (hasDoubleBondToO) {
               shouldContinue = true;
               break;
             }
           }
         }
         
         if (shouldContinue) {
           // This is likely an anhydride or mixed compound - continue through the oxygen
           dfsHeteroChain(nb, molecule, visited, currentChain, allChains, heteroAtoms, heteroAtomsToSkip);
         }
         
         visited.delete(nb);
         currentChain.pop();
       }
     } else if (nbAtom?.symbol === 'C') {
       // Normal carbon traversal
       dfsHeteroChain(nb, molecule, visited, currentChain, allChains, heteroAtoms, heteroAtomsToSkip);
     }
   }

   currentChain.pop();
   visited.delete(atom);
}

/**
 * Compute the longest simple path consisting only of carbon atoms.
 * This is a fallback candidate to ensure highly-branched molecules still
 * have their true longest carbon chain considered.
 */
function computeLongestCarbonPath(molecule: Molecule): number[] {
  // Prefer exhaustive enumeration of all simple carbon-only paths (deduplicated)
  // and select the longest one. This is more robust than a greedy DFS
  // which may miss long paths in branched graphs.
  try {
    const enumerated = enumerateAllSimpleCarbonPaths(molecule, molecule.atoms.length || 12);
    if (enumerated && enumerated.length > 0) {
      let best = enumerated[0]!;
      for (const p of enumerated) {
        if (p.length > best.length) best = p;
      }
      if (process.env.VERBOSE) {
        try {
          console.debug('[chain-selection] computeLongestCarbonPath (enumerated): best length', best.length, 'atoms', best);
        } catch (e) {}
      }
      return best;
    }
  } catch (e) {
    // fall through to DFS fallback
  }

  // Fallback: previous DFS-based approach
  const n = molecule.atoms.length;
  const isCarbon = (i: number) => molecule.atoms[i]?.symbol === 'C';
  let best: number[] = [];

  const visited = new Set<number>();

  function dfs(u: number, path: number[]) {
    if (path.length > best.length) best = path.slice();
    const neighbors = getNeighbors(u, molecule);
    for (const v of neighbors) {
      if (visited.has(v)) continue;
      if (!isCarbon(v)) continue;
      visited.add(v);
      path.push(v);
      dfs(v, path);
      path.pop();
      visited.delete(v);
    }
  }

  for (let i = 0; i < n; i++) {
    if (!isCarbon(i)) continue;
    visited.clear();
    visited.add(i);
    dfs(i, [i]);
  }

  if (process.env.VERBOSE) {
    try {
      console.debug('[chain-selection] computeLongestCarbonPath (fallback): best length', best.length, 'atoms', best);
    } catch (e) {}
  }

  return best;
}

/**
 * Enumerate all simple paths (no repeated nodes) composed only of carbon atoms up to maxLen.
 * Returns an array of paths (each path is an array of atom indices).
 */
function enumerateAllSimpleCarbonPaths(molecule: Molecule, maxLen = 12): number[][] {
  const n = molecule.atoms.length;
  const isCarbon = (i: number) => molecule.atoms[i]?.symbol === 'C';
  const results: number[][] = [];

  function dfs(path: number[], visited: Set<number>) {
    // record current path
    if (path.length >= 1) results.push(path.slice());
    if (path.length >= maxLen) return;
  const last = path[path.length - 1]!;
  const neighbors = getNeighbors(last, molecule);
    for (const nb of neighbors) {
      if (visited.has(nb)) continue;
      if (!isCarbon(nb)) continue;
      visited.add(nb);
      path.push(nb);
      dfs(path, visited);
      path.pop();
      visited.delete(nb);
    }
  }

  for (let i = 0; i < n; i++) {
    if (!isCarbon(i)) continue;
    const visited = new Set<number>([i]);
    dfs([i], visited);
  }

  // Deduplicate by sorted key to reduce equivalent permutations
  const seen = new Set<string>();
  const unique: number[][] = [];
  for (const p of results) {
    if (p.length < 2) continue;
    // Canonicalize acyclic path ordering (choose forward or reversed ordering
    // that yields the lower locant set) to make selector tie-breaking deterministic.
    const canonical = canonicalizeAcyclicChainOrder(p, molecule);
    const key = [...canonical].join(',');
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(canonical);
    }
  }
  return unique;
}

/**
 * For an acyclic chain (path), choose the orientation (forward or reversed)
 * that yields the IUPAC "lowest set of locants" for substituents so that
 * equivalent paths are presented in a canonical direction for comparison.
 */
function canonicalizeAcyclicChainOrder(chain: number[], molecule: Molecule): number[] {
  if (chain.length < 2) return chain.slice();
  // compute locants for forward and reversed order
  const forward = getSubstituentLocants(chain, molecule) || [];
  const reversedChain = [...chain].reverse();
  const reverse = getSubstituentLocants(reversedChain, molecule) || [];
  // If reversed locants are lower, return reversed ordering
  if (isLowerLocants(reverse, forward)) return reversedChain;
  return chain.slice();
}

/**
 * DFS to find the longest acyclic path from a starting atom.
 */
function dfsMaxChain(
   atom: number,
   molecule: Molecule,
   visited: Set<number>,
   currentChain: number[],
   allChains: number[][],
   aliphaticAtoms: Set<number>
 ): void {
   visited.add(atom);
   currentChain.push(atom);

   // Record this chain
   if (currentChain.length > 2) {
     allChains.push([...currentChain]);
   }

   // Try extending to neighbors
   const neighbors = getNeighbors(atom, molecule);
   let extended = false;

   for (const neighbor of neighbors) {
     // Only extend through aliphatic atoms (not aromatic ring atoms)
     if (!visited.has(neighbor) && aliphaticAtoms.has(neighbor)) {
       extended = true;
       dfsMaxChain(neighbor, molecule, visited, currentChain, allChains, aliphaticAtoms);
     }
   }

   // If no extension possible, this is a terminal chain
   // Include chains of length >= 1 to support single-carbon compounds like methanol
   if (!extended && currentChain.length >= 1) {
     allChains.push([...currentChain]);
   }

   // Backtrack
   currentChain.pop();
   visited.delete(atom);
 }

/**
 * Get neighboring atoms (connected by bonds).
 */
function getNeighbors(atomIdx: number, molecule: Molecule): number[] {
  const neighbors: number[] = [];
  for (const bond of molecule.bonds) {
    if (bond.atom1 === atomIdx) neighbors.push(bond.atom2);
    else if (bond.atom2 === atomIdx) neighbors.push(bond.atom1);
  }
  return neighbors;
}

/**
 * Find shortest path between two atoms using BFS.
 * Returns array of atom indices representing the path.
 */
function findShortestPath(start: number, end: number, molecule: Molecule): number[] {
  if (start === end) return [start];
  
  const queue: number[][] = [[start]];
  const visited = new Set<number>([start]);
  
  while (queue.length > 0) {
    const path = queue.shift()!;
    const current = path[path.length - 1]!;
    
    if (current === end) {
      return path;
    }
    
    const neighbors = getNeighbors(current, molecule);
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push([...path, neighbor]);
      }
    }
  }
  
  return []; // No path found
}

/**
 * Find longest path between two atoms that includes carbon atoms and allows traversal through
 * oxygen atoms in ether linkages (for dicarboxylic acids with ether substituents).
 * Returns array of atom indices representing the path.
 */
function findLongestPathWithEther(start: number, end: number, molecule: Molecule): number[] {
  if (start === end) return [start];
  
  // Use DFS to find all simple paths between start and end
  const allPaths: number[][] = [];
  const visited = new Set<number>();
  
  function dfs(current: number, target: number, path: number[]) {
    if (current === target) {
      allPaths.push([...path]);
      return;
    }
    
    if (visited.has(current)) return;
    
    visited.add(current);
    path.push(current);
    
    const neighbors = getNeighbors(current, molecule);
    for (const neighbor of neighbors) {
      const neighborAtom = molecule.atoms[neighbor];
      if (!neighborAtom) continue;
      
      // Allow traversal through carbon atoms
      if (neighborAtom.symbol === 'C') {
        dfs(neighbor, target, path);
      }
      // Allow traversal through oxygen atoms (ether linkages)
      else if (neighborAtom.symbol === 'O') {
        // Check if this oxygen connects to another carbon
        const oxygenNeighbors = getNeighbors(neighbor, molecule);
        for (const oNeighbor of oxygenNeighbors) {
          if (oNeighbor !== current && molecule.atoms[oNeighbor]?.symbol === 'C') {
            dfs(oNeighbor, target, path);
          }
        }
      }
    }
    
    path.pop();
    visited.delete(current);
  }
  
  dfs(start, end, []);
  
  // Return the longest path
  if (allPaths.length === 0) return [];
  return allPaths.reduce((longest, current) => current.length > longest.length ? current : longest);
}

/**
 * Get all carboxylic acid carbon atoms in the molecule.
 * A carboxylic acid carbon is one that has both a double bond to oxygen and a single bond to oxygen.
 */
function getAllCarboxylCarbons(molecule: Molecule): number[] {
  const carboxylCarbons: number[] = [];
  
  if (process.env.VERBOSE) {
    console.debug('[carboxyl-detection] Analyzing molecule with', molecule.atoms.length, 'atoms');
  }
  
  for (let i = 0; i < molecule.atoms.length; i++) {
    const atom = molecule.atoms[i];
    if (!atom || atom.symbol !== 'C') {
      if (process.env.VERBOSE && atom) {
        console.debug('[carboxyl-detection] Skipping atom', i, 'symbol:', atom.symbol);
      }
      continue;
    }
    
    const bonds = molecule.bonds.filter(b => b.atom1 === i || b.atom2 === i);
    let hasDoubleO = false;
    let hasSingleO = false;
    
    if (process.env.VERBOSE) {
      console.debug('[carboxyl-detection] Checking carbon atom', i, 'with', bonds.length, 'bonds:', bonds.map(b => `(${b.atom1}-${b.atom2}:${b.type})`));
    }
    
    for (const b of bonds) {
      const neighbor = molecule.atoms[b.atom1 === i ? b.atom2 : b.atom1];
      if (!neighbor) continue;
      
      if (neighbor.symbol === 'O') {
        if (process.env.VERBOSE) {
          console.debug('[carboxyl-detection] Carbon', i, 'bonded to oxygen', b.atom1 === i ? b.atom2 : b.atom1, 'type:', b.type);
        }
        if (b.type === BondType.DOUBLE) hasDoubleO = true;
        if (b.type === BondType.SINGLE) hasSingleO = true;
      }
    }
    
    // This is a carboxylic acid carbon if it has both =O and -O
    if (hasDoubleO && hasSingleO) {
      if (process.env.VERBOSE) {
        console.debug('[carboxyl-detection] Found carboxyl carbon at atom', i);
      }
      carboxylCarbons.push(i);
    }
  }
  
  if (process.env.VERBOSE) {
    console.debug('[carboxyl-detection] Final carboxyl carbons:', carboxylCarbons);
  }
  
  return carboxylCarbons;
}

/**
 * Detect if this is a simple malonic acid (OC(=O)CC(=O)O) vs a substituted variant.
 * Simple malonic acid has:
 * - Exactly 2 carboxyl carbons at distance 2
 * - Central carbon has no additional substituents except the two carboxyls
 * - No additional carbon branches
 */
function isSimpleMalonicAcid(molecule: Molecule, carboxylCarbons: number[], minDistance: number): boolean {
  if (minDistance !== 2 || carboxylCarbons.length !== 2) return false;
  
  // Find the central atom (one that connects to both carboxyls)
  const path = findShortestPath(carboxylCarbons[0]!, carboxylCarbons[1]!, molecule);
  if (path.length !== 3) return false; // Should be [carboxyl1, central, carboxyl2]
  
  const centralAtom = path[1]!;
  const centralAtomObj = molecule.atoms[centralAtom];
  
  // The central atom MUST be a carbon for true malonic acid
  // If it's O or N, this is an ester or amide, not a malonic acid
  if (!centralAtomObj || centralAtomObj.symbol !== 'C') {
    return false;
  }
  
  const centralNeighbors = getNeighbors(centralAtom, molecule);
  
  // Count non-carboxyl carbon neighbors
  const nonCarboxylCarbons = centralNeighbors.filter(neighbor => 
    molecule.atoms[neighbor]?.symbol === 'C' && !carboxylCarbons.includes(neighbor)
  );
  
  // Simple malonic acid should have no additional carbon substituents
  return nonCarboxylCarbons.length === 0;
}

/**
 * Count carbon atoms in a chain.
 */
function countCarbons(chain: number[], molecule: Molecule): number {
  let count = 0;
  for (const atomIdx of chain) {
    if (molecule.atoms[atomIdx]?.symbol === 'C') count++;
  }
  return count;
}

/**
 * Compute a simple unsaturation score for a candidate chain.
 * Score components:
 * - +1 for each double or triple bond between atoms inside the chain
 * - +1 for each aromatic atom in the chain (captures aromatic systems)
 */
function computeUnsaturationScore(chain: number[], molecule: Molecule): number {
  const chainSet = new Set(chain);
  let score = 0;
  for (const b of molecule.bonds) {
    if (chainSet.has(b.atom1) && chainSet.has(b.atom2)) {
      if (b.type === BondType.DOUBLE || b.type === BondType.TRIPLE) score++;
    }
  }
  for (const idx of chain) {
    if (molecule.atoms[idx]?.aromatic) score++;
  }
  return score;
}

/**
 * Get the positions of substituents on a chain (for numbering comparison).
 * Lower positions are better according to IUPAC rules.
 */
function getSubstituentLocants(chain: number[], molecule: Molecule): number[] {
  const chainLen = chain.length;
  const chainSet = new Set(chain);

  // Collect raw locant positions assuming the provided chain ordering is a possible numbering
  const rawLocants: number[] = [];
  for (let i = 0; i < chain.length; i++) {
    const atomIdx = chain[i]!;
    const neighbors = getNeighbors(atomIdx, molecule);
    for (const neighbor of neighbors) {
      if (!chainSet.has(neighbor)) {
        rawLocants.push(i + 1); // 1-based
        break;
      }
    }
  }

  // If no substituents, return empty list
  if (rawLocants.length === 0) return [];

  // Helper: compare two locant arrays lexicographically (IUPAC lowest-set rule)
  const compareLocantSets = (a: number[], b: number[]) => {
    const la = a.slice().sort((x, y) => x - y);
    const lb = b.slice().sort((x, y) => x - y);
    const len = Math.min(la.length, lb.length);
    for (let i = 0; i < len; i++) {
      if (la[i]! < lb[i]!) return -1;
      if (la[i]! > lb[i]!) return 1;
    }
    if (la.length < lb.length) return -1;
    if (la.length > lb.length) return 1;
    return 0;
  };

  // Detect whether chain is cyclic (first and last atoms bonded)
  const isChainCyclic = () => {
    if (chainLen < 3) return false;
    const first = chain[0]!;
    const last = chain[chainLen - 1]!;
    for (const b of molecule.bonds) {
      if ((b.atom1 === first && b.atom2 === last) || (b.atom2 === first && b.atom1 === last)) return true;
    }
    return false;
  };

  // For acyclic chains there are only two possible directionings; choose the better locant set
  if (!isChainCyclic()) {
    const forward = rawLocants.slice().sort((a, b) => a - b);
    const reverse = rawLocants.map(p => chainLen - p + 1).sort((a, b) => a - b);
    return compareLocantSets(forward, reverse) <= 0 ? forward : reverse;
  }

  // For cyclic chains, try all rotations and both directions (forward and reversed)
  const rotations: number[][] = [];
  // positions are 1-based indices in the original ordering
  const positions = rawLocants.slice();
  for (let start = 0; start < chainLen; start++) {
    // forward rotation
    const rotated = positions.map(p => ((p - start - 1 + chainLen) % chainLen) + 1).sort((a, b) => a - b);
    rotations.push(rotated);
    // reversed rotation
    const reversedPositions = positions.map(p => chainLen - p + 1);
    const revRot = reversedPositions.map(p => ((p - start - 1 + chainLen) % chainLen) + 1).sort((a, b) => a - b);
    rotations.push(revRot);
  }

  // Choose lexicographically smallest rotation
  rotations.sort((x, y) => {
    const len = Math.min(x.length, y.length);
    for (let i = 0; i < len; i++) {
      if (x[i]! < y[i]!) return -1;
      if (x[i]! > y[i]!) return 1;
    }
    return x.length - y.length;
  });
  return rotations[0] || [];
}

/**
 * Compare two sets of locants. Returns true if locants1 is "better" (lower) than locants2.
 */
function isLowerLocants(locants1: number[], locants2: number[]): boolean {
  const a = locants1.slice().sort((x, y) => x - y);
  const b = locants2.slice().sort((x, y) => x - y);
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (a[i]! < b[i]!) return true;
    if (a[i]! > b[i]!) return false;
  }
  return a.length < b.length;
}

export default selectPrincipalChain;

// Export helpers for debugging and tests
export { findChainsFromFunctionalGroups, findAllAcyclicChains, findHeteroatomChains, findRingBasedChains, getPrincipalFunctionalGroupAtoms };
